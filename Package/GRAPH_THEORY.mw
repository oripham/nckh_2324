<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="17" minor="0"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="false" autoexpanding_sections="true">
</View-Properties>
<MapleNet-Properties elisiondigitsbefore="100" labelling="true" indentamount="4" elisiontermsthreshold="10000" ansi="false" errorbreak="1" useclientjvm="true" echo="1" imaginaryunit="I" labelwidth="20" contextmenusize="automatic" plotdriver="opengl" elisiondigitsafter="100" plotoutput="terminal" helpbrowser="standard" rtablesize="10" elisiontermsbefore="100" elisiondigitsthreshold="10000" typesetting="standard" plotdevice="inline" verboseproc="1" showassumed="1" errorcursor="false" longdelim="true" plotoptions="" quiet="false" elisiontermsafter="100" screenwidth="79" preplot="" prettyprint="3" displayprecision="-1" screenpixelheight="1080" warnlevel="3" screenheight="25" latexwidth="8.0" postplot="" prompt="&gt; " ShowLabels="true"/>
<Styles>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="true"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input" background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Output" background="[0,0,0]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 1" background="[0,0,0]" bold="true" executable="false" family="Serif" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text" background="[0,0,0]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 2" background="[0,0,0]" bold="true" executable="false" family="Serif" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="16" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Annotation Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.5" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
</Styles>
<Task-table>
    <Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/>
<Section collapsed="false" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title>
<Text-field style="Heading 1" layout="Heading 1"><Font encoding="UTF-8">DEMO MINH H\341\273\214A M\303\224 H\303\214NH SUB-COKB TR\303\212N MI\341\273\200N TRI TH\341\273\250C L\303\235 THUY\341\272\276T \304\220\341\273\222 TH\341\273\212</Font></Text-field></Title>
<Group labelreference="L160" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYtLUkjbWlHRiQ2JVEtR1JBUEhfVEhFT1JZRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEifkYnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR0ZMLUY2Ni1RKiZjb2xvbmVxO0YnRjlGO0Y+RkBGQkZERkZGSC9GS1EsMC4yNzc3Nzc4ZW1GJy9GTkZTRjUtRiw2JVEmdGFibGVGJ0YvRjItSShtZmVuY2VkR0YkNiQtRiM2JS1GLDYjUSFGJy8lK2V4ZWN1dGFibGVHRj1GOUY5LUY2Ni1RIjpGJ0Y5RjtGPkZARkJGREZGRkhGUkZULUknbXNwYWNlR0YkNiYvJSdoZWlnaHRHUSYwLjBleEYnLyUmd2lkdGhHRkwvJSZkZXB0aEdGZG8vJSpsaW5lYnJlYWtHUSVhdXRvRidGZ25Gam5GOQ==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYrLUkjbWlHRiQ2JVEtR1JBUEhfVEhFT1JZRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEifkYnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR0ZMLUY2Ni1RKiZjb2xvbmVxO0YnRjlGO0Y+RkBGQkZERkZGSC9GS1EsMC4yNzc3Nzc4ZW1GJy9GTkZTRjUtRiw2JVEmdGFibGVGJ0YvRjItSShtZmVuY2VkR0YkNiQtRiM2Iy1GLDYjUSFGJ0Y5LUY2Ni1RIjpGJ0Y5RjtGPkZARkJGREZGRkhGUkZULUknbXNwYWNlR0YkNiYvJSdoZWlnaHRHUSYwLjBleEYnLyUmd2lkdGhHRkwvJSZkZXB0aEdGYm8vJSpsaW5lYnJlYWtHUSVhdXRvRidGZ24=</Equation></Text-field>
</Input>
</Group>
<Section collapsed="false" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title>
<Text-field style="Heading 2" layout="Heading 2"><Font encoding="UTF-8">Th\341\273\247 t\341\273\245c kh\341\273\237i t\341\272\241o</Font></Text-field></Title>
<Group labelreference="L5">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,102,255]">GRAPH_THEORY[init] := proc()
</Font><Font bold="false">global <Font foreground="[255,102,102]">url,</Font>Obj_Structs, Rela_Structs, Rule_Structs,RuleEqs_Structs,Fun_Names, Func_Structs, O_Hypos_Rules;<Font foreground="[255,102,102]">
local read_ObjName,read_Relas,read_Rules,read_Function,read_FuncStructs;
</Font></Font>
#------------------------------------------<Font style="Text">
<Font encoding="UTF-8"># Th\341\273\247 t\341\273\245c \304\221\341\273\215c file OBJECTS.txt v\303\240 l\306\260u v\303\240o Obj_Structs</Font></Font><Font foreground="[153,51,255]">
read_ObjName := proc()</Font><Font bold="false">
  local  line, s, fd;
  Obj_Structs := [];
  fd := fopen(cat(url,&quot;/data/OBJECTS.txt&quot;), READ, TEXT);
  line := readline(fd);
  while line &lt;&gt; 0 and SearchText(&quot;begin_Objects&quot;, line) = 0  do
     line := readline(fd);
  od;
  line := readline(fd);
  while line &lt;&gt; 0 and SearchText(&quot;end_Objects&quot;, line) = 0  do
    s := convert(parse(line), string);
    if s &lt;&gt; &quot;&quot; then
      Obj_Structs := [op(Obj_Structs),[s,[]]];
    fi;
    line := readline(fd);
  od;
  fclose(fd);</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  read_ObjName</Font>
#-----------------------------------------<Font style="Text">

<Font encoding="UTF-8"># Th\341\273\247 t\341\273\245c \304\221\341\273\215c file RELATIONS.txt v\303\240 l\306\260u v\303\240o Rela_Structs</Font></Font><Font foreground="[153,51,255]">
read_Relas := proc()</Font><Font bold="false">
  local  line, expr, fd;
  Rela_Structs := [];
  fd := fopen(cat(url,&quot;/data/RELATIONS.txt&quot;), READ, TEXT);
  line := readline(fd);
  while line &lt;&gt; 0 and SearchText(&quot;begin_Relations&quot;, line) = 0  do
     line := readline(fd);
  od;
  line := readline(fd);
  while line &lt;&gt; 0 and SearchText(&quot;end_Relations&quot;, line) = 0 do
    expr := [parse(line)];
    if  nops(expr) = 2 then
       expr[1] := map(s-&gt;convert(s, string), expr[1]);
       Rela_Structs := [op(Rela_Structs), expr];
    fi;
    line := readline(fd);
  od;
  fclose(fd);</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  read_Relas</Font>
#-----------------------------------------<Font style="Text">

<Font encoding="UTF-8"># Th\341\273\247 t\341\273\245c \304\221\341\273\215c file RULES.txt v\303\240 l\306\260u v\303\240o Rule_Structs</Font></Font><Font foreground="[153,51,255]">
read_Rules := proc()</Font><Font bold="false">
local  fd,  read_1Rule, line,thutuc;

 <Font foreground="[153,51,255]"> read_1Rule := proc()</Font>
    local  loai, tens, kieus, ten1, n1, kieu1, gt_kl, k;
    loai := &quot;&quot;;  tens := [];  kieus := [];  gt_kl := [{},{}];thutuc:=&quot;&quot;;

    line := readline(fd);
    while line &lt;&gt; 0 and SearchText(&quot;begin_rule&quot;, line)=0 and SearchText(&quot;end_rules&quot;, line)= 0 do
         line := readline(fd);
    od;

    if  SearchText(&quot;end_rules&quot;, line) &gt; 0 then  
         RETURN(NULL);
    fi;

    line := readline(fd);
    while line &lt;&gt; 0 and SearchText(&quot;end_rule&quot;, line) = 0 do
      if  SearchText(&quot;kind_rule&quot;, line) &gt; 0  then  
        loai := rhs(parse(line));
      else
        k := SearchText(&quot;:&quot;, line);
        if  SearchText(&quot;hypothesis_part&quot;, line) &gt; 0  then
          gt_kl[1] := substring(line, (k+1)..length(line));
          line := readline(fd);
          while line &lt;&gt; 0 and SearchText(&quot;end_hypothesis_part&quot;, line) = 0  do
            gt_kl[1] := cat (gt_kl[1], line);
            line := readline(fd);
         od;
          gt_kl[1] := parse(gt_kl[1]);
        elif  SearchText(&quot;goal_part&quot;, line) &gt; 0  then
          gt_kl[2] := substring(line, (k+1)..length(line));
          line := readline(fd);
          while line &lt;&gt; 0 and SearchText(&quot;end_goal_part&quot;, line) = 0  do
            gt_kl[2] := cat (gt_kl[2], line);
            line := readline(fd);
          od;
          gt_kl[2] := parse(gt_kl[2]);<Font foreground="[0,255,51]">
       </Font><Font foreground="[255,51,51]"> elif  SearchText(&quot;proc&quot;, line) &gt; 0  then
            thutuc:=parse(substring(line,SearchText(&quot;:&quot;, line)+1...length(line)));
            </Font>
        elif  k &gt; 0  then
          ten1 := [parse( substring(line, 1..(k-1)) )];  n1 := nops(ten1);
          kieu1 := convert ( parse( substring(line, (k+1)..length(line)) ), string);
          tens := [op(tens), op(ten1)];  kieus := [op(kieus), kieu1 $ n1];
        fi;
      fi;
      line := readline(fd);
    od;
    if  ten &lt;&gt; [] then 
       if loai=&quot;GRAPH_VERTEX_IN_GRAPH&quot; then 
             RuleEqs_Structs := [op(RuleEqs_Structs), [loai, tens, kieus, gt_kl,thutuc]];
       else
             Rule_Structs := [op(Rule_Structs), [loai, tens, kieus, gt_kl,thutuc]];
       fi;
    fi;
  <Font foreground="[153,51,255]">end:  </Font></Font><Font style="Text" executable="true">#  Read_1Rule</Font><Font bold="false">

  Rule_Structs := [];
  RuleEqs_Structs:=[];
  fd := fopen(cat(url,&quot;/data/RULES.txt&quot;), READ,TEXT);
  line := readline(fd);
  while  line &lt;&gt; 0 and SearchText(&quot;begin_rules&quot;, line) = 0  do
    line := readline(fd);
  od;
  while  line &lt;&gt; 0 and SearchText(&quot;end_rules&quot;, line) = 0  do
    read_1Rule();
  od;
  fclose(fd);</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  read_Rules</Font>
#--------------------------------------------------<Font style="Text">

<Font encoding="UTF-8"># Th\341\273\247 t\341\273\245c \304\221\341\273\215c file FUNCTIONS.txt v\303\240 l\306\260u v\303\240o Fun_Names</Font></Font><Font foreground="[153,102,255]">
read_Function:=proc()</Font><Font bold="false">
  local fd, line, s, j, tri, ten, bien, tc;
  Fun_Names:=[];
  fd:=fopen(cat(url,&quot;/data/FUNCTIONS.txt&quot;), READ, TEXT);
  line:= readline(fd);
  while line &lt;&gt; 0 and SearchText(&quot;begin_functions&quot;,line) = 0 do
    line:=readline(fd);
  od;
  line:= readline(fd);
  while line &lt;&gt; 0 and SearchText(&quot;end_functions&quot;, line) = 0 do
   
       tri:=substring(line,1..SearchText(&quot; &quot;,line)-1);
       ten:=substring(line,SearchText(&quot; &quot;,line)+1..SearchText(&quot;(&quot;,line)-1);
       bien:=map(s-&gt;convert(s,string),[parse(substring(line,SearchText(&quot;(&quot;,line)..SearchText(&quot;)&quot;,line)))]);
       tc:= parse(substring(line,SearchText(&quot;{&quot;,line)..SearchText(&quot;}&quot;,line)));
       Fun_Names:=[op(Fun_Names),[tri,ten,bien,tc]];
    line := readline(fd);
  od;
  fclose(fd);</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  read_Function</Font>
#--------------------------------------------------<Font style="Text">

<Font encoding="UTF-8"># Th\341\273\247 t\341\273\245c \304\221\341\273\215c file DEFINE-FUNCTIONS.txt v\303\240 \304\221\306\260a v\303\240o Func_Structs</Font></Font><Font bold="false" foreground="[0,0,0]" size="14"> </Font><Font foreground="[153,51,255]">
read_FuncStructs:=proc()</Font><Font bold="false">
local  fd,  read_Func, line,t,
	Init,ReadName,ReadBaseO,ReadReturn,ReadProc,ReadProp,ReadFunc,</Font>
	<Font bold="false">NameF,BaseOF,ReturnOF,ProcF,PropF;<Font foreground="[153,51,255]">

Init:=proc()</Font>
 NameF:=&quot;&quot;;
 BaseOF:=[[],[]];
 ReturnOF:=[];
 ProcF:=&quot;&quot;;
 PropF:=[];
 t:=&quot;&quot;;<Font foreground="[153,51,255]">
end:  </Font></Font><Font style="Text" executable="true"># Init</Font><Font bold="false" foreground="[153,51,255]">

ReadName := proc()</Font><Font bold="false">
local k, s;
    k:=SearchText(&quot;:&quot;,line);
    s:=substring(line,k+1..length(line)); 
    NameF := convert(parse(s),string);</Font>
   <Font bold="false"> t:=substring(NameF,SearchText(&quot;(&quot;,NameF)..length(NameF));<Font foreground="[153,51,255]">
end:  </Font></Font><Font style="Text" executable="true"># ReadName</Font><Font bold="false" foreground="[153,51,255]">

ReadBaseO := proc()</Font><Font bold="false">
local k, lst, s, name, listO, listT ;
   listO := [];   
   listT := [];
   line := readline(fd);
   while line &lt;&gt; 0 and SearchText(&quot;return&quot;,line)=0    do
      k := SearchText(&quot;:&quot;,line);
      if  k &gt; 0 then
         lst := [parse(substring(line,1..(k-1)))];
         listO := [op(listO),op(lst)];
         s := substring(line,(k+1)..length(line));
	 name := convert(parse(s),string);
         listT := [op(listT), name $ nops(lst)];
      fi;
      line := readline(fd);
   od;
   BaseOF := [listO, listT];<Font foreground="[153,51,255]">
end:  </Font></Font><Font style="Text" executable="true">#  ReadBaseO</Font><Font bold="false" foreground="[153,51,255]">

ReadReturn:=proc()</Font>
  <Font bold="false">local k, s,t;
    k := SearchText(&quot;:&quot;,line);
    if k&gt;0 then
      t:=parse(substring(line,SearchText(&quot;return&quot;,line)+6..k-1));   
      s:=convert(parse(substring(line,k+1..length(line))),string);
      ReturnOF := [t,s];</Font>
    <Font bold="false">fi;</Font>   <Font bold="false" foreground="[153,102,255]">
end:  </Font><Font style="Text" executable="true">#  ReadReturn</Font><Font bold="false" foreground="[153,51,255]">

ReadProc:=proc()</Font><Font bold="false">
line := readline(fd);
while line &lt;&gt; 0 and  SearchText(&quot;end_proc&quot;,line)=0 do
  ProcF:=cat(ProcF,line);
  line := readline(fd);
od;
ProcF:=cat(&quot;proc&quot;,t,ProcF,&quot;end:&quot;);<Font foreground="[153,51,255]">
end:  </Font></Font><Font style="Text" executable="true">#  ReadProc</Font><Font bold="false" foreground="[153,51,255]">

ReadProp:=proc()</Font><Font bold="false">
local ex;
  line := readline(fd);
  while line &lt;&gt; 0 and  SearchText(&quot;end_properties&quot;,line)=0 do
    ex := parse(line);
    if evalb(ex &lt;&gt; NULL) then
      PropF := [op(PropF),ex];
    fi;
    line := readline(fd);
  od;<Font foreground="[153,51,255]">
end:  </Font></Font><Font style="Text" executable="true">#  ReadProp</Font><Font bold="false" foreground="[153,51,255]">

ReadFunc:=proc()</Font><Font bold="false">
Init();
line := readline(fd);

    while line &lt;&gt; 0 and SearchText(&quot;begin_function&quot;, line)=0 and SearchText(&quot;end_functions&quot;, line)= 0 do
         line := readline(fd);
    od;

    if  SearchText(&quot;end_functions&quot;, line) &gt; 0 then  
        RETURN(NULL);
    fi;    
    while line &lt;&gt; 0 and SearchText(&quot;end_function&quot;, line) = 0 do</Font><Font style="Text">
         </Font><Font bold="false"> if SearchText(&quot;begin_function&quot;, line) &gt; 0 then
    		ReadName(); 
		ReadBaseO();next;
          elif SearchText(&quot;return&quot;, line) &gt; 0 then ReadReturn();
          elif SearchText(&quot;begin_proc&quot;, line) &gt; 0 then ReadProc();
          elif SearchText(&quot;properties&quot;, line) &gt; 0 then ReadProp();
          fi;
	  line := readline(fd);
   od; </Font>
   <Font bold="false">line := readline(fd);</Font>
   <Font bold="false">if  NameF &lt;&gt; &quot;&quot; then  Func_Structs := [op(Func_Structs), [NameF,BaseOF,ReturnOF,ProcF,PropF]];fi;<Font foreground="[153,51,255]">
end: </Font></Font><Font style="Text" executable="true"> #  ReadFunc</Font><Font style="Text">


# read_FuncStruct's body</Font><Font bold="false">
 Func_Structs := [];
  fd := fopen(cat(url,&quot;/data/DEFINE-FUNCTIONS-tmp.txt&quot;), READ,TEXT);
  line := readline(fd);
  while  line &lt;&gt; 0 and SearchText(&quot;begin_functions&quot;, line) = 0  do
    line := readline(fd);
  od;
  while  line &lt;&gt; 0 and SearchText(&quot;end_functions&quot;, line) = 0  do
    ReadFunc();
  od;
  fclose(fd);</Font><Font foreground="[153,102,255]">
end proc:  </Font><Font style="Text" executable="true"># read_FuncStructs</Font>

#------------------------------------------------------<Font style="Text">

#---------------------------------------------------------------------------------------------------
Init's body</Font><Font bold="false" foreground="[255,51,51]">
 O_Hypos_Rules:=[];
 read_ObjName();
 read_Relas();
 read_Rules();
 read_Function();
 read_FuncStructs();</Font><Font foreground="[153,102,255]">

end: </Font><Font style="Text" executable="true">#GRAPH_THEORY[Init]</Font></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title>
<Text-field style="Heading 2" layout="Heading 2"><Font encoding="UTF-8">C\303\241c th\341\273\247 t\341\273\245c \304\221\341\273\215c file d\341\273\257 li\341\273\207u</Font>
ReadCObject;
ObjStruct;</Text-field></Title>
<Group labelreference="L6">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text" encoding="UTF-8"># Th\341\273\247 t\341\273\245c \304\221\341\273\215c file &lt;t\303\252n \304\221\341\273\221i t\306\260\341\273\243ng&gt;.txt : \304\221\341\273\215c c\341\272\245u tr\303\272c c\341\273\247a t\341\273\253ng \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font foreground="[153,51,255]">
GRAPH_THEORY[ReadCObject] := proc(filename::string)</Font><Font bold="false">
local
   keyword, 
   nameO, AttrO, typeAttr, Constraint, Property, CRelation, Rule, BaseO,
   ConstructPro, DeterO, InsideNet, ConstructRela,Func,
   result, 
   fd, line, s, f,
   Init, Readname, ReadBaseO, Readvariables, ReadConstructRela, Readconstraints, 

   Readproperties, ReadConstructPro, Readrelations, Readrules, Readfunctions;
   <Font foreground="[153,51,255]">
Init := proc()</Font>
  keyword := [&quot;begin_object&quot;, &quot;end_object&quot;, &quot;begin_variables&quot;, &quot;end_variables&quot;, 
    &quot;begin_constraints&quot;, &quot;end_constraints&quot;, &quot;begin_properties&quot;, &quot;end_properties&quot;,
    &quot;begin_computation_relations&quot;, &quot;end_computation_relations&quot;, 
    &quot;begin_rules&quot;, &quot;end_rules&quot;, 
    &quot;begin_construct_relations&quot;, &quot;end_construct_relations&quot;];

  nameO := &quot;&quot;;         </Font><Font style="Text" encoding="UTF-8">#  l\306\260u t\303\252n c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
  BaseO := [ [], [] ]; </Font><Font style="Text" encoding="UTF-8"># l\306\260u c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng c\306\241 s\341\273\237 (\304\221\341\273\221i t\306\260\341\273\243ng n\341\273\201n) bao g\341\273\223m: (1)_l\306\260u t\303\252n c\341\273\247a c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng c\306\241 s\341\273\237; (2)_l\306\260u ki\341\273\203u c\341\273\247a c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng c\306\241 s\341\273\237</Font><Font bold="false">
  AttrO := []; 				        </Font><Font style="Text" encoding="UTF-8"># l\306\260u t\303\252n c\303\241c thu\341\273\231c t\303\255nh c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
  typeAttr := [];      </Font><Font style="Text" encoding="UTF-8"># l\306\260u ki\341\273\203u c\341\273\247a c\303\241c thu\341\273\231c t\303\255nh c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
  Constraint := [];    </Font><Font style="Text" encoding="UTF-8">#  l\306\260u \304\221i\341\273\201u ki\341\273\207n r\303\240ng bu\341\273\231c c\341\273\247a c\303\241c thu\341\273\231c t\303\255nh c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
  ConstructRela := []; </Font><Font style="Text" encoding="UTF-8"># l\306\260u quan h\341\273\207 c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng n\341\273\201n</Font><Font bold="false">
  Property := [];      </Font><Font style="Text" encoding="UTF-8">#  l\306\260u t\303\255nh ch\341\272\245t c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
  CRelation := [];     </Font><Font style="Text" encoding="UTF-8">#  l\306\260u c\303\241c quan h\341\273\207 t\303\255nh to\303\241n c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
  Rule := [];</Font><Font style="Text" encoding="UTF-8">                        #   l\306\260u t\341\272\255p lu\341\272\255t c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
  Func:=[];</Font><Font style="Text" encoding="UTF-8">                            # l\306\260u c\303\241c h\303\240m c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false" foreground="[204,51,255]">
end: </Font><Font style="Text" executable="true"># Init</Font><Font bold="false" foreground="[153,51,255]">

Readname := proc() </Font><Font style="Text" executable="true" encoding="UTF-8"># \304\220\341\273\215c t\303\252n c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
local k, s;
  k := SearchText(&quot;:&quot;,line);
  s := substring(line,(k+1)..length(line));
  nameO := convert(parse(s),string);<Font foreground="[153,51,255]">
end: </Font></Font><Font style="Text" executable="true"># Readname</Font><Font bold="false" foreground="[153,51,255]">

ReadBaseO := proc()</Font><Font bold="false"> </Font><Font style="Text" encoding="UTF-8"># \304\220\341\273\215c c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng c\306\241 s\341\273\237 bao g\341\273\223m: c\341\272\243 t\303\252n \304\221\341\273\221i t\306\260\341\273\243ng v\303\240 ki\341\273\203u c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
local k, lst, s, name, listO, listT ;
   listO := [];   
   listT := [];
   line := readline(fd);
   while line &lt;&gt; 0 and SearchText(&quot;begin_variables&quot;,line)=0    do
      k := SearchText(&quot;:&quot;,line);
      if  k &gt; 0 then
         lst := [parse(substring(line,1..(k-1)))];  
         listO := [op(listO),op(lst)];

         s := substring(line,(k+1)..length(line));
	 name := convert(parse(s),string);

         listT := [op(listT), name $ nops(lst)];
      fi;
      line := readline(fd);
   od;
   BaseO := [listO, listT];<Font foreground="[153,51,255]">
end: </Font></Font><Font style="Text" executable="true"> #  ReadBaseO</Font><Font bold="false" foreground="[153,51,255]">

Readvariables := proc()</Font><Font bold="false"> </Font><Font style="Text" encoding="UTF-8">#  \304\220\341\273\215c c\303\241c thu\341\273\231c t\303\255nh c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
local k, i, lst, lst1, s, name;
  line := readline(fd);
  while line &lt;&gt; 0 and SearchText(&quot;end_variables&quot;,line)=0   do
    k := SearchText(&quot;:&quot;,line);
    if k &gt; 0 then
      lst := [parse(substring(line,1..(k-1)))]; </Font><Font style="Text" encoding="UTF-8">#  L\306\260u t\303\252n c\341\273\247a thu\341\273\231c t\303\255nh</Font><Font bold="false"> 
      s := substring(line,(k+1)..length(line)); </Font><Font style="Text" encoding="UTF-8">#  L\306\260u ki\341\273\203u c\341\273\247a thu\341\273\231c t\303\255nh</Font><Font bold="false">     
      name := convert(parse(s),string);

      lst1 := [seq(name,i=1..nops(lst))];
      AttrO := [op(AttrO),op(lst)];
      typeAttr := [op(typeAttr),op(lst1)];
    fi;
    line := readline(fd);
  od;<Font foreground="[153,51,255]">
end: </Font></Font><Font style="Text" executable="true"># Readvariables</Font><Font bold="false" foreground="[153,51,255]">

Readconstraints := proc() </Font><Font style="Text" encoding="UTF-8"># \304\220\341\273\215c r\303\240ng bu\341\273\231c</Font><Font bold="false">
local expr;
  line := readline(fd);
  while line &lt;&gt; 0 and  SearchText(&quot;end_constraints&quot;,line)=0 do
    expr := parse(line);
    if evalb(expr &lt;&gt; NULL) then
      Constraint := [op(Constraint), expr];
    fi;
    line := readline(fd);
  od;<Font foreground="[153,51,255]">
end: </Font></Font><Font style="Text" executable="true"># Readconstraints</Font><Font bold="false" foreground="[153,51,255]">

ReadConstructRela := proc()</Font><Font bold="false"> </Font><Font style="Text" encoding="UTF-8">#  \304\220\341\273\215c quan h\341\273\207 thi\341\272\277t l\341\272\255p</Font><Font bold="false">
local  expr;
  line := readline(fd);
  while line &lt;&gt; 0 and SearchText(&quot;end_construct_relations&quot;,line)=0   do
     expr := parse(line);
     if evalb(expr &lt;&gt; NULL) then
        ConstructRela := [op(ConstructRela), expr];
     fi;
     line := readline(fd);
  od;<Font foreground="[153,51,255]">
end:  </Font></Font><Font style="Text" executable="true"># ReadConstructRela</Font><Font bold="false" foreground="[153,51,255]">

Readproperties := proc() </Font><Font style="Text" encoding="UTF-8"># \304\220\341\273\215c t\303\255nh ch\341\272\245t c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
local expr;
  line := readline(fd);
  while line &lt;&gt; 0 and  SearchText(&quot;end_properties&quot;,line)=0 do
    expr := parse(line);
    if evalb(expr &lt;&gt; NULL) then
      Property := [op(Property),expr];
    fi;
    line := readline(fd);
  od;<Font foreground="[153,51,255]">
end: </Font></Font><Font style="Text" executable="true"># Readproperties</Font><Font bold="false" foreground="[153,51,255]">

Readrelations := proc() </Font><Font style="Text" encoding="UTF-8"># \304\220\341\273\215c quan h\341\273\207 t\303\255nh to\303\241n c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
local leftname, expr, strlist, k, f, Readrelation;

  <Font foreground="[153,51,255]">Readrelation := proc()</Font>
    f[1] := line; 
    line := readline(fd);
    while line &lt;&gt; 0 and SearchText(&quot;end_relation&quot;,line)=0 do
      leftname := convert(lhs(parse(line)), string);
      expr := rhs(parse(line));
      if (member(leftname,strlist,'k')) then
        if leftname = &quot;expf&quot; then 
          f[k]:=parse(expr);
        else
        f[k] := expr;fi;
      fi;
      line := readline(fd);
    od;
  end: </Font><Font style="Text" executable="true"># Readrelation</Font><Font bold="false">

  f := [&quot;&quot;,1,{},1,{},1=1,0]; # khoi tao f
  strlist := [&quot;&quot;,&quot;flag&quot;,&quot;Mf&quot;,&quot;rf&quot;,&quot;vf&quot;,&quot;expf&quot;,&quot;cost&quot;];
  line := readline(fd);
  while line &lt;&gt; 0 and  SearchText(&quot;end_computation_relations&quot;,line)=0 do
    if (SearchText(&quot;begin_relation&quot;,line) &gt; 0) then
      Readrelation();
      CRelation := [op(CRelation), f];
    fi;
    line := readline(fd);
  od;<Font foreground="[153,51,255]">
end: </Font></Font><Font style="Text" executable="true"># Readrelations</Font><Font bold="false" foreground="[153,51,255]">


Readrules := proc() </Font><Font style="Text" executable="true" encoding="UTF-8"># \304\220\341\273\215c t\341\272\255p lu\341\272\255t c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
local    read_1Rule;

   read_1Rule := proc()
   local  loai, tens, kieus, ten1, n1, kieu1, gt_kl, k,thutuc;
      loai := &quot;&quot;;  tens := [];  kieus := [];  gt_kl := [{},{}];thutuc:=&quot;&quot;;
      line := readline(fd);
      while line &lt;&gt; 0 and SearchText(&quot;begin_rule&quot;, line) = 0 and 
            SearchText(&quot;end_rules&quot;, line) = 0 do
         line := readline(fd);
      od;
      if  SearchText(&quot;end_rules&quot;, line) &gt; 0 then
         RETURN (NULL);
      fi;
      line := readline(fd);
      while line &lt;&gt; 0 and SearchText(&quot;end_rule&quot;, line) = 0 do
         if  SearchText(&quot;kind_rule&quot;, line) &gt; 0  then  
            loai := rhs(parse(line));
         else
            k := SearchText(&quot;:&quot;, line);
            if  SearchText(&quot;hypothesis_part&quot;, line) &gt; 0  then
               gt_kl[1] := substring(line, (k+1)..length(line));
               line := readline(fd);
<Font encoding="UTF-8">               while line &lt;&gt; 0 and SearchText(&quot;end_hypothesis_part&quot;, line) = 0  do\134
</Font>
                  gt_kl[1] := cat (gt_kl[1], line);
                  line := readline(fd);
               od;
               gt_kl[1] := parse(gt_kl[1]);
            elif  SearchText(&quot;goal_part&quot;, line) &gt; 0  then
               gt_kl[2] := substring(line, (k+1)..length(line));
               line := readline(fd);
               while line &lt;&gt; 0 and SearchText(&quot;end_goal_part&quot;, line) = 0  do
                  gt_kl[2] := cat (gt_kl[2], line);
                  line := readline(fd);
               od;
               gt_kl[2] := parse(gt_kl[2]);
            <Font foreground="[255,51,51]">elif  SearchText(&quot;proc&quot;, line) &gt; 0  then
            thutuc:=parse(substring(line,SearchText(&quot;:&quot;, line)+1...length(line)));
            </Font>
            elif  k &gt; 0  then
               ten1 := [parse( substring(line, 1..(k-1)) )];  n1 := nops(ten1);
               kieu1 := convert ( parse( substring(line, (k+1)..length(line)) ), string);

               tens := [op(tens), op(ten1)];  kieus := [op(kieus), kieu1 $ n1];
            fi;
         fi;
         line := readline(fd);
      od;
      if  ten &lt;&gt;[] then  
         Rule := [op(Rule), [loai, tens, kieus, gt_kl,thutuc] ];
      fi;
      
   end:  #  Read_1Rule

   while  line &lt;&gt; 0 and SearchText(&quot;end_rules&quot;, line) = 0  do
      read_1Rule();
   od;<Font foreground="[153,102,255]">
end: </Font></Font><Font style="Text" executable="true"># Readrules</Font><Font bold="false" foreground="[153,51,255]">

Readfunctions:=proc() </Font><Font style="Text" executable="true" encoding="UTF-8"># \304\220\341\273\215c c\303\241c h\303\240m c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng</Font><Font bold="false">
 local expr;
  line := readline(fd);
  while line &lt;&gt; 0 and  SearchText(&quot;end_functions&quot;,line)=0 do
    expr := parse(line);
    if evalb(expr &lt;&gt; NULL) then
      Func := [op(Func),expr];
    fi;
    line := readline(fd);
  od;  <Font foreground="[153,51,255]">
end: </Font></Font><Font style="Text" executable="true"># Readfunctions</Font><Font style="Text">

# ReadCObject's main body</Font><Font bold="false">
Init();
fd := fopen(filename,READ,TEXT);
line := readline(fd);
while line &lt;&gt; 0 and SearchText(&quot;begin_object&quot;, line)=0 do
   line := readline(fd);
od;
while line &lt;&gt; 0 and SearchText(&quot;end_object&quot;, line)=0 do
  if SearchText(&quot;begin_object&quot;, line) &gt; 0 then
    Readname();      ReadBaseO();   next;
  elif SearchText(&quot;begin_variables&quot;,line) &gt; 0 then    Readvariables();
  elif SearchText(&quot;begin_constraints&quot;,line) &gt; 0 then    Readconstraints();
  elif  SearchText(&quot;begin_construct_relations&quot;,line) &gt; 0 then ReadConstructRela(); 
  elif SearchText(&quot;begin_properties&quot;,line) &gt; 0 then    Readproperties();
  elif SearchText(&quot;begin_computation_relations&quot;,line) &gt; 0 then Readrelations();
  elif SearchText(&quot;begin_rules&quot;,line) &gt; 0 then    Readrules();
  elif SearchText(&quot;begin_functions&quot;,line) &gt; 0 then    Readfunctions();
  fi;
  line := readline(fd);
od;
fclose(fd);
result := [nameO,BaseO,[AttrO,typeAttr],Constraint,ConstructRela,Property,CRelation, Rule,Func];
RETURN(result);</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  ReadCObject</Font>
</Text-field>
</Input>
</Group>
<Group labelreference="L7">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L8">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[ObjStruct] := proc(Obj_name::string, s)</Font><Font style="Text">
<Font encoding="UTF-8">#  Th\341\273\247 t\341\273\245c ki\341\273\203m tra Obj_name c\303\263 thu\341\273\231c t\341\272\255p OBJECTS l\306\260u tr\341\273\257 kh\303\264ng? v\303\240 l\341\272\245y ra c\303\241c c\341\272\245u tr\303\272c c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng (n\341\272\277u c\303\263)</Font></Font><Font bold="false">
global Obj_Structs;
local i,flag;flag:=0;
  for i from 1 to nops(Obj_Structs) do
    if evalb(Obj_Structs[i][1]=Obj_name) then
      flag:=1;break;
    fi;
  od;
  if(flag=0)then return(NULL);fi;
  if  nargs = 2 and s = &quot;reset&quot;  then  Obj_Structs[i][2] := [];  RETURN (NULL);  fi;
  if Obj_Structs[i][2] = [] then
    Obj_Structs[i][2]:= ReadCObject(cat(url,&quot;/data/&quot;,Obj_name,&quot;.txt&quot;));
  fi;
  RETURN(Obj_Structs[i][2]);</Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Text" executable="true">#  ObjStruct</Font></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title>
<Text-field style="Heading 2" layout="Heading 2"><Font encoding="UTF-8">C\303\241c th\341\273\247 t\341\273\245c h\341\273\227 tr\341\273\243 c\306\241 b\341\272\243n
</Font>Is_Equal;
SubList;
Is_RelationType; RelaProp;
Is_DacTrung;
NameType;
ValidStructName_Onet;
Set_Vars;</Text-field></Title>
<Group labelreference="L9">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Is_Equal] := proc(expr1,expr2) </Font><Font style="Text" executable="true" encoding="UTF-8">#  Th\341\273\247 t\341\273\245c ki\341\273\203m tra s\341\273\261 b\341\272\261ng nhau c\341\273\247a hai bi\341\273\203u th\341\273\251c expr1 v\303\240 expr2</Font><Font bold="false">
local flag, i,j;<Font foreground="[51,0,51]">  
 </Font></Font><Font style="Text" encoding="UTF-8"> #  Tr\306\260\341\273\235ng h\341\273\243p expr1 v\303\240 expr2 \304\221\341\273\201u l\303\240 ki\341\273\203u danh s\303\241ch</Font><Font bold="false">
  if  type(expr1,list) and type(expr2,list)  then
    if  nops(expr1) &lt;&gt; nops(expr2)  then      RETURN(false);
    fi;
    for i from 1 to nops(expr1) do
      if  not <Font foreground="[255,51,102]">Is_Equal</Font>(expr1[i],expr2[i])  then        RETURN(false);
      fi;
    od;
    RETURN(true);
  fi;
 <Font foreground="[51,0,51]"> </Font></Font><Font style="Text"># <Font encoding="UTF-8">Tr\306\260\341\273\235ng h\341\273\243p expr1 v\303\240 expr2 \304\221\341\273\201u l\303\240 ki\341\273\203u t\341\272\255p h\341\273\243p</Font></Font><Font bold="false">
  if  type(expr1,set) and type(expr2,set)  then
    for i in expr1 do
      flag := false;
      for j in expr2 do
        if <Font foreground="[255,51,51]">Is_Equal</Font>(i,j) then  flag := true;  break;
        fi; 
      od;
      if not flag then  RETURN(false);
      fi;
    od;
    for i in expr2 do
      flag := false;
      for j in expr1 do
        if</Font><Font foreground="[255,102,102]"> Is_Equal</Font><Font bold="false">(i,j) then  flag := true;  break;
        fi; 
      od;
      if not flag then  RETURN(false);
      fi;
    od;
    RETURN(true);
  fi;
  </Font><Font style="Text" encoding="UTF-8">#  Tr\306\260\341\273\235ng h\341\273\243p kh\303\241c</Font><Font bold="false">
  flag := evalb(expr1 = expr2);
  if flag = false and not type(expr1,string) and not type(expr1,string) then  
    <Font foreground="[255,51,51]">if type(expr1, polynom) and type(expr2, polynom) then    </Font>
       flag := evalb(simplify(expand(expr1-expr2))=0);
    elif <Font foreground="[255,51,51]">type(expr1, `=`) and type(expr2, `=`) then    </Font>
       flag := evalb(simplify(expand(</Font>abs(<Font bold="false">lhs(expr1)-rhs(expr1))-</Font>abs(<Font bold="false">lhs(expr2)-rhs(expr2))))=0);
    fi;
  fi;
  RETURN(flag);</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Is_Equal</Font></Text-field>
</Input>
</Group>
<Group labelreference="L10">
<Input>
<Text-field style="Text" layout="Normal">Is_Equal((m+1)^2,m^2+2*m+1):
Is_Equal([1,2],m^2+2*m+1):</Text-field>
</Input>
</Group>
<Group labelreference="L11">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#---------------</Text-field>
</Input>
</Group>
<Group labelreference="L12">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[SubList]:=proc(list1,list2)</Font><Font bold="false">
local i,j,B,flag1; 
B:=list2;
if nops(list1) &gt; nops(list2) then return false;fi;
if  not `subset`(convert(list1,set),convert(list2,set)) then return false;fi;
for i to nops(list1) do
   flag1:=0;
   for j to nops(B) do
     if B[j]=list1[i] then 
        B[j]:=&quot;&quot;;
        flag1:=1;
        break;
     fi;
   od;
   if flag1=0 then return false;fi;
od;
return true;</Font><Font foreground="[153,102,255]">
end proc:  </Font><Font style="Text" executable="true">#  SubList</Font></Text-field>
</Input>
</Group>
<Group labelreference="L13">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------------</Text-field>
</Input>
</Group>
<Group labelreference="L14">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Is_RelationType] := proc(slist::list,s)</Font><Font bold="false"> </Font><Font style="Text" encoding="UTF-8"># ki\341\273\203m tra slist c\303\263 ph\341\272\243i l\303\240 m\341\273\231t quan h\341\273\207 hay kh\303\264ng? 
</Font><Font style="Text"># vd: slist := [&quot;SSONG&quot;, &quot;DOAN&quot;, &quot;DOAN&quot;]</Font><Font bold="false">
local nlist, i;
  nlist := map(s-&gt;NameType(s), slist);
  for  i from 1 to nops(Rela_Structs)  do
    if nargs = 1 then 
     if  nlist = Rela_Structs[i] [1]  then  return true;fi;
     if Rela_Structs[i] [1][1]=nlist[1] and member(&quot;doi xung&quot;, Rela_Structs[i] [2]) and evalb(convert(nlist,set)= convert(Rela_Structs[i][1],set))then 
        return true ;
     fi;
    else 
      if  nlist = Rela_Structs[i] [1]  then  return Rela_Structs[i][1];fi;
     if Rela_Structs[i] [1][1]=nlist[1] and member(&quot;doi xung&quot;, Rela_Structs[i] [2]) and evalb(convert(nlist,set)= convert(Rela_Structs[i][1],set))then 
        return Rela_Structs[i][1] ;
     fi;
    fi; 
  end do;  
  return false;</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Is_RelationType</Font></Text-field>
</Input>
</Group>
<Group labelreference="L15">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#----------------------</Text-field>
</Input>
</Group>
<Group labelreference="L16">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[RelaProp] :=  proc(slist::list,prop::string)</Font><Font bold="false"> </Font><Font style="Text"># kiem tra tinh chat prop co la tinh 				chat cua quan he slist
# Neu khong co doi thu hai thi RETURN (tap cac tinh chat cua quan he)</Font><Font bold="false">
local nlist, i;
  nlist := map(s-&gt;NameType(s), slist);
  for  i from 1 to nops(Rela_Structs)  do
     if  nlist = Rela_Structs[i] [1]   then
        if  nargs = 1  then  RETURN (Rela_Structs[i][2]);
        elif  member(prop, Rela_Structs[i] [2])  then  RETURN (true);
        else  RETURN (false);
        fi;
     fi;
  end do;
  if  nargs = 1 then  RETURN ({});  
  else RETURN(false);
  fi;</Font><Font foreground="[153,51,255]">
end proc: </Font><Font style="Text" executable="true">#  RelaProp</Font></Text-field>
</Input>
</Group>
<Group labelreference="L17">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#----------------</Text-field>
</Input>
</Group>
<Group labelreference="L18">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Is_DacTrung]:=proc(O1,O2)</Font> <Font style="Text"># kiem tap O1 co la tinh chat dac trung cua O2 khong</Font><Font bold="false" foreground="[255,51,51]">
local rule,r;
    for rule in ObjStruct(type_Onet(O2))[8] do
         if evalb(rule[1] = &quot;xac_dinh_doi_tuong&quot;) then  
            r:= map(s-&gt;O2.s,rule[4][1]); 
            if evalb(O1 = r)  then 
               if type_Onet(O2)=&quot;DUONGTHANG&quot; or type_Onet(O2)=&quot;DOAN&quot; then
                  if evalb(op(O1)[2]=a) then return false;fi;
               fi;
               return true;
            fi;
         fi;
      od;</Font> 
   <Font bold="false">return false;</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true"># IsDacTrung</Font></Text-field>
</Input>
</Group>
<Group labelreference="L19">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------</Text-field>
</Input>
</Group>
<Group labelreference="L20">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[NameType] := proc(s)</Font><Font style="Text"># lay ten cua doi tuong vd: DOAN[A,B] -----&gt; DOAN</Font><Font bold="false">
local k;
  if  type(s, string)  then
     k := SearchText(&quot;[&quot;,s);
     if k &gt; 0 then RETURN(substring(s,1..(k-1)));
     else  RETURN(s);
     fi;
  fi;
  if  type(s, indexed)  then  RETURN( convert(op(0,s), string) );
  fi;
  RETURN (&quot;?&quot;);</Font><Font foreground="[153,51,255]">
end proc: </Font><Font style="Text" executable="true">#  NameType</Font></Text-field>
</Input>
</Group>
<Group labelreference="L21">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L22">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[ValidStructName_Onet] := proc(name)</Font><Font bold="false"> </Font><Font style="Text"># Xet tinh hop le cua mot cau truc</Font><Font bold="false">
 <Font foreground="[255,51,51]"> </Font></Font><Font style="Text"># Kiem tra tinh hop le cua mot ten cau truc nhu:  DOAN[A,B]</Font><Font bold="false" foreground="[255,51,51]">
local   Sn1;
   if  not type(name, indexed)  then  RETURN (false);
   fi;
   if  not member(NameType(name), map(x-&gt;x[1],Obj_Structs))  then  RETURN (false);
   fi;
   Sn1 := parse(ObjStruct(NameType(name)) [1]);
   if  not type(Sn1, indexed) or nops(name) &lt;&gt; nops(Sn1)  then
      RETURN (false);
  fi;
  RETURN (true);</Font><Font foreground="[153,51,255]">
end proc: </Font><Font style="Text" executable="true"># ValidStructName_Onet</Font></Text-field>
</Input>
</Group>
<Group labelreference="L23">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-----------------</Text-field>
</Input>
</Group>
<Group labelreference="L24">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Set_Vars]:=proc(expr)</Font>
  <Font bold="false" foreground="[255,51,102]">local F,i;
  if  type(expr, constant)  or type(expr, string) then  RETURN ({});
  elif type(expr,`name`)or type(expr,`indexed`) or type(expr, function) then return {expr};
  elif type(expr,`set`) or type(expr,list)then
     F:={}; 
     for i in expr do
         if not member(i,{x,y})then
         F:= F union Set_Vars(i);fi;
     od; 
     return F;
 else F:= Set_Vars({op(expr)});
       return F;
  fi;</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Set_Vars</Font></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title>
<Text-field style="Heading 2" layout="Heading 2"><Font encoding="UTF-8">C\303\241c th\341\273\247 t\341\273\245c x\341\273\255 l\303\275 tr\303\252n m\341\272\241ng Onet theo m\303\264 h\303\254nh b\303\240i to\303\241n </Font>
Is_Element;
Has_Element;
Is_Object;
Has_Object;
Is_Function;
type_Onet;
Find_Fact_Types;
AttrName;
StructName;</Text-field></Title>
<Group labelreference="L25">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Is_Element] := proc(ex)</Font><Font bold="false">
      if  member(ex, Objects) or member(ex, OAttrs) then  RETURN (true);
      elif  type(ex, function) and op(0,ex)=`.` and ( member(op(1,ex), Objects) or (ValidStructName_Onet(op(1,ex))) and SubList([op(op(1,ex))],Objects)) then
          RETURN (true);
     </Font><Font style="Text">  </Font><Font bold="false">elif  ValidStructName_Onet(ex) and SubList([op(ex)],Objects) then  RETURN (true);
     
      fi;
      RETURN (false);</Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true">#  Is_Element</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[Has_Element] := proc(ex)</Font><Font bold="false">
   local  i;
      for i in ex  do
         if  Is_Element(i)  then  RETURN (true);fi;
      end do;
      RETURN (false);</Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Text" executable="true">#  Has_Element</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[Is_Object]:=proc(ex)</Font>
   <Font bold="false">local i;
      for i in Obj_Structs do
          if evalb(convert(ex,string) = i[1]) then return true;fi;
      od;   
      return false;</Font><Font style="Text">

 </Font><Font foreground="[153,51,255]">end proc: </Font><Font style="Text" executable="true">#  Is_Object</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[</Font><Font bold="true" style="Text"> </Font><Font foreground="[153,51,255]">Has_Object] := proc(ex)</Font>
   <Font bold="false">local  i;
      for i in ex  do
         if not Is_Object(i)  then  return false;fi;
      end do;
      RETURN (true);</Font><Font foreground="[153,51,255]">

end proc:  </Font><Font style="Text" executable="true">#</Font><Font style="Text">   <Font executable="true">Has_Object </Font></Font><Font foreground="[153,51,255]">

GRAPH_THEORY[Is_Function]:=proc(ex)</Font><Font style="Text">
   </Font><Font bold="false">  local k,t,i;
     <Font foreground="[255,51,51]"> t:=convert(ex,string);</Font>
      k:= SearchText(&quot;(&quot;,t);
      if type(ex,function) and k &lt;&gt; 0  then
          if SubList([op(ex)],Objects) then return true;fi;
          for i in op(ex) do
           <Font foreground="[255,51,51]">  if Is_Function(i) or (ValidStructName_Onet(i) and SubList([op(i)],Objects)) then return true;fi;</Font>
          od;
          return false;
      fi; 
      return false;</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Is_Function</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[Has_Function] := proc(ex)</Font><Font bold="false">
   local  i;
      for i in ex  do
         if  Is_Function(i)  then  RETURN (true);fi;
      end do;
      RETURN (false);</Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Text" executable="true">#  Has_Function</Font></Text-field>
</Input>
</Group>
<Group labelreference="L26">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-----------------</Text-field>
</Input>
</Group>
<Group labelreference="L27">
<Input>
<Text-field bookmark="OS" prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[ObjStruct_Replace]:=proc(d)</Font><Font bold="false">
local OSTemp,i,k,thaythe;

OSTemp:=<Font foreground="[255,51,51]">ObjStruct(type_Onet(d));</Font>
OSTemp:=subs(&quot;Object&quot;=d,seq(OSTemp[3][1][i]=d.OSTemp[3][1][i],i=1..nops(OSTemp[3][1])),OSTemp);

thaythe:={};<Font foreground="[255,51,102]">

if type(d,indexed) then</Font>  
       OSTemp:=subs(seq([op(parse(OSTemp[1]))][i]=[op(d)][i],i=1..nops([op(d)])),OSTemp);<Font foreground="[255,102,102]">
       </Font>OSTemp[3][2]:=map(s-&gt;convert(subs(seq([op(parse(OSTemp[1]))][i]=[op(d)][i],i=1..nops([op(d)])),parse(s)),string),OSTemp[3][2]);<Font foreground="[255,102,102]">
       OSTemp[1]:=</Font>convert(subs(seq([op(parse(OSTemp[1]))][i]=[op(d)][i],i=1..nops([op(d)])),parse(OSTemp[1])),string); 
       
       for k to nops(OSTemp[3][1]) do
          if SearchText(&quot;Goc&quot;,convert(OSTemp[3][1][k],string))&gt;0 then 
                  thaythe:={op(thaythe),OSTemp[3][1][k]=d.parse(cat(&quot;Goc&quot;,op(parse(OSTemp[3][2][k]))[2]))};
          fi;
       od;<Font foreground="[255,102,102]">
       
else
   for i in Fact_Kinds[1] do
      if i[1]=d and type(parse(i[2]),indexed)then
         </Font>OSTemp:=subs(seq([op(parse(OSTemp[1]))][j]=[op(parse(i[2]))][j],j=1..nops([op(parse(i[2]))])),OSTemp);<Font foreground="[255,102,102]">
         </Font>OSTemp[3][2]:=map(s-&gt;convert(subs(seq([op(parse(OSTemp[1]))][j]=[op(parse(i[2]))][j],j=1..nops([op(parse(i[2]))])),parse(s)),string),OSTemp[3][2]);<Font foreground="[255,102,102]">
         OSTemp[1]:=</Font>convert(subs(seq([op(parse(OSTemp[1]))][j]=[op(parse(i[2]))][j],j=1..nops([op(parse(i[2]))])),parse(OSTemp[1])),string);<Font foreground="[255,102,102]">

         </Font>for k to nops(OSTemp[3][1]) do
          if SearchText(&quot;Goc&quot;,convert(OSTemp[3][1][k],string))&gt;0 then 
                 thaythe:={op(thaythe),OSTemp[3][1][k]=d.parse(cat(&quot;Goc&quot;,op(parse(OSTemp[3][2][k]))[2]))};
          fi;
       od;<Font foreground="[255,102,102]">
      fi;
   od;
fi;</Font>

OSTemp:=subs(thaythe,OSTemp);

return OSTemp;</Font><Font foreground="[153,102,255]">
end:  </Font><Font style="Text" executable="true"># ObjStruct_Replace</Font></Text-field>
</Input>
</Group>
<Group labelreference="L28">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------------</Text-field>
</Input>
</Group>
<Group labelreference="L29">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[type_Onet] := proc(element,ds)</Font><Font bold="false">
  </Font><Font style="Text"># cho biet kieu cua mot &lt;object&gt; hay mot thuoc tinh tren mang CONet.
  # vi du ve cac truong hop cua element:  O1, Ob.a, Ob.DOAN[A,B]
  # RETURN &lt;type cua element&gt; hoac la &quot;type?&quot;
global  Objs_CONet, Otypes_CONet;</Font><Font bold="false">
local  k,i, Otype, nameA,OS;

   if  member(element, Objects, 'k')  then  RETURN (Obj_Types [k]);
   #elif  member(element, OAttrs, 'k')  then  RETURN (OAttr_Types [k]);
   elif  type(element, function) and op(0, element) = `.`  then
      Otype := type_Onet(op(1, element));
      if  Otype = &quot;type?&quot;  then  RETURN (&quot;type?&quot;);
      fi;
      nameA := op(2, element);</Font><Font style="Text">#Vd   O.DOAN[A,B]</Font><Font bold="false">
      if  type(nameA, indexed)  then  RETURN (NameType(nameA));
      else 
         <Font foreground="[255,102,102]">OS:=ObjStruct_Replace(</Font>op(1, element)<Font foreground="[255,102,102]">);</Font>
         if  member(element, OS[3][1], 'k')  then  RETURN (OS[3][2][k]);fi;
      fi;
      
   elif  type(element, indexed)   then  # vd ve element: DOAN[M,A]
      RETURN (NameType(element));

  <Font foreground="[51,51,255]"> </Font><Font foreground="[255,51,51]">elif Is_Function(element) then 
      for i in Fun_Names do
        if i[2]=convert(op(0,element), string) and (evalb(i[3]=[seq(type_Onet([</Font>op(element)]<Font foreground="[255,51,51]">[i],1),i=1..nops([</Font>op(element)<Font foreground="[255,51,51]">]))]) or ( member(&quot;doi xung&quot;, i[4])and convert(i[3], set) = {seq(type_Onet([</Font>op(element)]<Font foreground="[255,51,51]">[i],1),i=1..nops([</Font>op(element)<Font foreground="[255,51,51]">]))})) then 
        if (nargs=2 ) then RETURN(i[1]);
        else RETURN(i);fi
        fi;od;</Font>
   fi;
   </Font><Font style="Text">#  Khong biet kieu gi</Font><Font bold="false">
   RETURN (&quot;type?&quot;);</Font><Font foreground="[153,102,255]">
end proc:  </Font><Font style="Text" executable="true">#  type_Onet</Font></Text-field>
</Input>
</Group>
<Group labelreference="L30">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L31">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Find_Fact_Types]:=proc(Facts,ds)</Font>
  <Font style="Text"># Tim kieu doi tuong cho cac sk trong Facts</Font><Font bold="false">
local fact,Types; </Font>
     <Font bold="false"> Types:=[]; 
      for fact in Facts do
        if(nargs=2) then 
          <Font foreground="[255,102,102]"> Types:=[op(Types),type_Onet(fact,1)];
        else 
           Types:=[op(Types),type_Onet(fact)];fi;
      od; </Font>
      return Types;</Font>
   <Font foreground="[153,51,255]">end proc:  </Font><Font style="Text" executable="true">#  Find_Fact_Types</Font></Text-field>
</Input>
</Group>
<Group labelreference="L32">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-----------------</Text-field>
</Input>
</Group>
<Group labelreference="L33">
<Input>
<Text-field bookmark="at" prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[AttrName]:=proc(ex)</Font><Font style="Text">
#xac dinh ten thuoc tinh tu ten cau truc
#VD: Goc[A,B,C] la cau truc cua thuoc tinh GocB .</Font><Font bold="false">
local OS,temp, prop,p;
if not (type(ex,function)and op(0,ex)=`.` and type(op(2,ex),indexed)) then return ex;fi;
OS:=ObjStruct(convert(op(0,op(2,ex)),string));
if member(convert(op(2,ex),string),ObjStruct_Replace(op(1,ex))[3][2],'k') then 
     return ObjStruct_Replace(op(1,ex))[3][1][k];
fi;       
prop:=subs(seq([op(parse(OS[1]))][i]=[op(op(2,ex))][i],i=1..nops([op(op(2,ex))])),OS[6]);
for p in prop do
   if type(p,`=`) then
       temp:=&quot;&quot;;
       if lhs(p)=op(2,ex) then temp:=rhs(p);
       elif rhs(p)=op(2,ex)  then temp:=lhs(p);              
       fi; 
       if temp &lt;&gt; &quot;&quot; and member(convert(temp,string),ObjStruct_Replace(op(1,ex))[3][2],'k') then   return ObjStruct_Replace(op(1,ex))[3][1][k];fi;
   fi;  
od;  <Font foreground="[255,51,102]">
return ex;</Font></Font><Font foreground="[153,102,255]">
end:  </Font><Font style="Text" executable="true"># AttrName</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[StructName]:=proc(ex)</Font><Font style="Text">
# xac dinh cau truc cua mot thuoc tinh cua doi tuong
# VD: thuoc tinh GocB co cau truc Goc[A.B,C]</Font><Font bold="false">
if not (type(ex,function)and op(0,ex)=`.` ) then return ex;fi;
if member(ex,ObjStruct_Replace(op(1,ex))[3][1],'k') then 
     return op(1,ex).parse(ObjStruct_Replace(op(1,ex))[3][2][k]);
fi;<Font foreground="[255,51,102]">
return ex;</Font></Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># StructName</Font></Text-field>
</Input>
</Group>
<Group labelreference="L34">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title>
<Text-field style="Heading 2" layout="Heading 2"><Font encoding="UTF-8">Ph\303\242n lo\341\272\241i s\341\273\261 ki\341\273\207n v\303\240 H\341\273\243p nh\341\272\245t s\341\273\261 ki\341\273\207n tr\303\252n ONet</Font>
Kind_Fact;
Unify_Fact;
Unify_In;Unify_In1;
Classify_Facts;
Intersect_Unify;Minus_Unify;Union_Unify;
Find_VarUnify;
Replace_StructName;Replace_AttrName;
</Text-field></Title>
<Group labelreference="L35">
<Input>
<Text-field bookmark="Kind_Fact" prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Kind_Fact]:=proc(fact)</Font>
  <Font style="Text" encoding="UTF-8"># Ph\303\242n lo\341\272\241i s\341\273\261 ki\341\273\207n t\341\273\253 s\341\273\261 ki\341\273\207n 1 \304\221\341\272\277n s\341\273\261 ki\341\273\207n 11 theo th\341\273\251 t\341\273\261</Font><Font style="Text">    </Font><Font bold="false">
global  Objects, Obj_Types, OAttrs, OAttr_Types; 
local temp, i; </Font><Font style="Text">
   </Font>#print(&quot;---------------------&quot; , fact);<Font style="Text">
<Font encoding="UTF-8">    # S\341\273\261 ki\341\273\207n lo\341\272\241i 1: S\341\273\261 ki\341\273\207n th\303\264ng tin v\341\273\201 lo\341\272\241i c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng------------VD: </Font></Font><Font bold="false">
 <Font foreground="[0,51,255]"> </Font><Font foreground="[255,0,102]">if  type(fact, list)</Font> then
     if nops(fact)=2 and 
        (member(fact[1],Objects) or (<Font foreground="[255,51,102]">ValidStructName_Onet(fact[1]))and SubList([op(fact[1])],Objects))and</Font> 
        type(fact[2],string) and member(NameType(fact[2]),Obj_Types) then return 1; <Font foreground="[0,0,0]">

 </Font></Font><Font style="Text" encoding="UTF-8"> # S\341\273\261 ki\341\273\207n lo\341\272\241i 6: S\341\273\261 ki\341\273\207n v\341\273\201 m\341\273\231t quan h\341\273\207 tr\303\252n c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng hay tr\303\252n c\303\241c thu\341\273\231c t\303\255nh c\341\273\247a c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng ---- VD: </Font><Font bold="false">
      elif nops(fact) &gt; 1 then 
        temp:=fact;
        for i from 2 to nops(fact) do
           if member(fact[i],[op(Objects),op(OAttrs)] , 'k') then 
              temp[i] := NameType([op(Obj_Types),op(OAttr_Types)][k]);
           elif <Font foreground="[255,51,102]">ValidStructName_Onet(fact[i]) and SubList([op(fact[i])],</Font>Objects<Font foreground="[255,51,102]">) then </Font>
               temp[i] := NameType(fact[i]);
           elif <Font foreground="[255,51,102]">Is_Function(fact[i]) then</Font>
               temp[i]:= type_Onet(fact[i])[1];
           elif type(fact[i],function) and op(0,fact[i])=`.` then 
               temp[i]:=NameType(type_Onet(fact[i]));
           else  temp[i] := &quot;?&quot;;fi;
        od;
        if Is_RelationType(temp) then return  6;  fi; 
      fi; 
  
  </Font><Font style="Text" encoding="UTF-8"># S\341\273\261 ki\341\273\207n lo\341\272\241i 2: S\341\273\261 ki\341\273\207n v\341\273\201 t\303\255nh x\303\241c \304\221\341\273\213nh c\341\273\247a m\341\273\231t \304\221\341\273\221i t\306\260\341\273\243ng hay c\341\273\247a m\341\273\231t thu\341\273\231c t\303\255nh c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng-------VD:</Font><Font bold="false">
  elif Is_Element(fact) then  return 2; 
 
  elif type(fact,`=`) and Is_Element(lhs(fact))  then 
  </Font><Font style="Text" encoding="UTF-8"># S\341\273\261 ki\341\273\207n lo\341\272\241i 4: S\341\273\261 ki\341\273\207n v\341\273\201 s\341\273\261 b\341\272\261ng nhau c\341\273\247a m\341\273\231t \304\221\341\273\221i t\306\260\341\273\243ng hay thu\341\273\231c t\303\255nh c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng v\341\273\233i m\341\273\231t \304\221\341\273\221i t\306\260\341\273\243ng hay m\341\273\231t thu\341\273\231c t\303\255nh kh\303\241c
</Font><Font style="Text">     # VD:    </Font><Font bold="false">
      if  Is_Element(rhs(fact))  then   return 4;
 </Font><Font style="Text" encoding="UTF-8">  # S\341\273\261 ki\341\273\207n lo\341\272\241i 9: S\341\273\261 ki\341\273\207n v\341\273\201 s\341\273\261 b\341\272\261ng nhau gi\341\273\257a m\341\273\231t \304\221\341\273\221i t\306\260\341\273\243ng v\341\273\233i m\341\273\231t h\303\240m_ &lt;doi tuong&gt; = &lt;ham&gt; </Font><Font bold="false" foreground="[255,51,102]">
      elif Is_Function(rhs(fact)) then return 9;</Font><Font bold="false">
  </Font><Font style="Text" encoding="UTF-8"># S\341\273\261 ki\341\273\207n lo\341\272\241i 3: S\341\273\261 ki\341\273\207n v\341\273\201 t\303\255nh x\303\241c \304\221\341\273\213nh c\341\273\247a m\341\273\231t \304\221\341\273\221i t\306\260\341\273\243ng hay c\341\273\247a m\341\273\231t thu\341\273\231c t\303\255nh c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng th\303\264ng qua m\341\273\231t bi\341\273\203u th\341\273\251c h\341\272\261ng</Font><Font bold="false">
      elif  not Has_Element( Set_Vars(rhs(fact)) )  then   return 3;
 </Font><Font style="Text" encoding="UTF-8">  # S\341\273\261 ki\341\273\207n lo\341\272\241i 5: S\341\273\261 ph\341\273\245 thu\341\273\231c gi\341\273\257a c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng, thu\341\273\231c t\303\255nh c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng th\303\264ng qua m\341\273\231t c\303\264ng th\341\273\251c t\303\255nh to\303\241n hay m\341\273\231t \304\221\341\272\263ng th\341\273\251c theo c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng  ho\341\272\267c c\303\241c thu\341\273\231c t\303\255nh</Font><Font bold="false">
      else  return 5;
      fi;
 </Font><Font style="Text"> </Font><Font bold="false">elif type(fact,`=`) and (Has_Element( Set_Vars(lhs(fact)) ) or Has_Element( Set_Vars(rhs(fact)) )) then return 5;
 </Font><Font style="Text" encoding="UTF-8">  # S\341\273\261 ki\341\273\207n lo\341\272\241i 7: S\341\273\261 ki\341\273\207n v\341\273\201 t\303\255nh x\303\241c \304\221\341\273\213nh c\341\273\247a m\341\273\231t h\303\240m </Font><Font bold="false">
  elif Is_Function(fact) then return 7;
 </Font><Font style="Text">  </Font><Font bold="false">elif type(fact,`=`) and Is_Function(lhs(fact)) then
  </Font><Font style="Text" encoding="UTF-8"># S\341\273\261 ki\341\273\207n lo\341\272\241i 10: S\341\273\261 ki\341\273\207n v\341\273\201 s\341\273\261 b\341\272\261ng nhau c\341\273\247a 1 h\303\240m v\341\273\233i 1 h\303\240m kh\303\241c_&lt;ham&gt;=&lt;ham&gt;</Font><Font bold="false">
          if  Is_Function(rhs(fact)) then return 10;</Font> <Font bold="false">
  </Font><Font style="Text" encoding="UTF-8"># S\341\273\261 ki\341\273\207n lo\341\272\241i 8: S\341\273\261 ki\341\273\207n v\341\273\201 t\303\255nh x\303\241c \304\221\341\273\213nh c\341\273\247a 1 h\303\240m th\303\264ng qua m\341\273\231t bi\341\273\203u th\341\273\251c h\341\272\261ng</Font><Font bold="false">
          elif  not Has_Element( Set_Vars(rhs(fact)) ) and not Has_Function(Set_Vars(rhs(fact)) ) then   return 8;
                      
  </Font><Font style="Text" encoding="UTF-8"># S\341\273\261 ki\341\273\207n lo\341\272\241i 11: S\341\273\261 ph\341\273\245 thu\341\273\231c c\341\273\247a 1 h\303\240m theo c\303\241c h\303\240m hay c\303\241c \304\221\341\273\221i t\306\260\341\273\243ng kh\303\241c th\303\264ng qua m\341\273\231t c\303\264ng th\341\273\251c t\303\255nh to\303\241n.</Font><Font bold="false">
          else return 11;
     	  fi;
 fi;
return 0;</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Kind_Fact</Font></Text-field>
</Input>
</Group>
<Group labelreference="L36">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#---------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L37">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Unify_Fact]:=proc(fact1,fact2) </Font><Font style="Text" executable="true" encoding="UTF-8">#  Th\341\273\247 t\341\273\245c ki\341\273\203m tra s\341\273\261 h\341\273\243p nh\341\272\245t gi\341\273\257a 2 s\341\273\261 ki\341\273\207n c\303\271ng lo\341\272\241i</Font> 
<Font bold="false" foreground="[255,51,51]">local k1,k2,vars1, vars2,i,j,p, temp,prop,tam1, tam2,
       TestDX,Func_DX;</Font><Font style="Text">
</Font><Font bold="false" foreground="[153,51,255]">
 TestDX := proc()   </Font><Font style="Text" encoding="UTF-8"># Th\341\273\247 t\341\273\245c con: Ki\341\273\203m tra s\341\273\261 ki\341\273\207n lo\341\272\241i 6 c\303\263 t\303\255nh \304\221\341\273\221i x\341\273\251ng hay kh\303\264ng?</Font><Font bold="false" foreground="[0,0,255]">
  </Font><Font bold="false" foreground="[255,51,51]">local type1, type2, n1, n2, 
      i, j, k, expr1, expr2, flag;
    if  fact1[1] &lt;&gt; fact2[1]  then  RETURN (false);
    fi;
    type1 := fact1;  n1 := nops(fact1);
    type2 := fact2;  n2 := nops(fact2);
    for i from 2 to n1 do
       if  type(type1[i], indexed)  then type1[i]:= convert(op(0,type1[i]), string);
       else
          type1[i]:= type_Onet(type1[i],1);
       fi;
    od;
    for i from 2 to n2 do
       if  type(type2[i], indexed)  then type2[i]:= convert(op(0,type2[i]), string);
       else
          type2[i]:= type_Onet(type2[i],1);
       fi;
    od;</Font><Font bold="false" foreground="[0,0,255]">
    </Font><Font bold="false" foreground="[255,102,102]">if  RelaProp(type1,&quot;doi xung&quot;) or  RelaProp(type2,&quot;doi xung&quot;) then
      expr1 := convert(fact1[2..n1],set);      expr2 := convert(fact2[2..n2],set);
      for i in expr1  do
         flag := false;
         for j in expr2  do
            if  Unify_Fact(i, j)  then  flag := true;
            fi;
         end do;
         if  flag =</Font><Font foreground="[255,102,102]"> false  then  RETURN (false);
         fi;<Font bold="false">
      end do;
      for i in expr2  do
         flag := false;
         for j in expr1  do
            if  Unify_Fact(i, j)  then  flag := true;
            fi;
     </Font></Font><Font bold="false" foreground="[255,51,51]">    end do;
         if  flag = false  then  RETURN (false);
         fi;
      end do;
      RETURN(true);
    elif  n1 &lt;&gt; n2  then  RETURN(false);
    else
       for  i from 2 to n1  do
          if  not Unify_Fact(fact1[i], fact2[i])  then  RETURN(false);
          fi;
       end do;
       RETURN(true);  
    fi;
</Font><Font bold="false" foreground="[153,102,255]"> end: </Font><Font style="Text" executable="true"># TestDX</Font>  
 
 <Font bold="false" foreground="[153,51,255]"> Func_DX:=proc() </Font><Font style="Text" executable="true" encoding="UTF-8">#  Th\341\273\247 t\341\273\245c con: Ki\341\273\203m tra xem 1 h\303\240m c\303\263 t\303\255nh \304\221\341\273\221i x\341\273\251ng hay kh\303\264ng?</Font>
  <Font bold="false">local name, type1, type2, tinhchat, func, f ;
     if fact1 = fact2 then return true;fi;
     if op(0,fact1) = op(0,fact2) and  nops([op(fact1)]) = nops([op(fact2)]) 
        and {op(fact1)} = {op(fact2)}  then   
         name:=convert(op(0,fact1),string) ;
         type1:= Find_Fact_Types([op(fact1)]);
         type2:= Find_Fact_Types([op(fact2)]);
         if SubList(type1,type2) and  SubList(type2,type1) then 
             for func in Fun_Names do
                 if evalb(name = func[2]) and SubList(type1,func[3]) and 
                    SubList(func[3],type1)  then   break;fi;     
             od;
         fi;
         if member(&quot;doi xung&quot;, func[4]) then return true;fi;
     fi; </Font>
     <Font bold="false">return false;
  <Font foreground="[153,51,255]">end: </Font></Font><Font style="Text" executable="true"># Func_DX</Font><Font bold="false">

</Font><Font style="Text" executable="true" encoding="UTF-8"># B\341\272\257t \304\221\341\272\247u ki\341\273\203m tra s\341\273\261 h\341\273\243p nh\341\272\245t c\341\273\247a 2 s\341\273\261 ki\341\273\207n</Font><Font bold="false">
  k1:=Kind_Fact(fact1);
  k2:=Kind_Fact(fact2);
  if k1 &lt;&gt; k2 then return false; fi; </Font><Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u </Font><Font style="Text" executable="true">fact1, fact2<Font encoding="UTF-8"> kh\303\241c ki\341\273\203u th\303\254 kh\303\264ng x\303\251t-&gt; kh\303\264ng h\341\273\243p nh\341\272\245t</Font></Font>
<Font style="Text" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 1 </Font>
 <Font bold="false"> if k1 = 1 then 
     if Unify_Fact(fact1[1],fact2[1]) then 
        if type_Onet(fact1[1])=&quot;GRAPH&quot; or </Font>type_Onet(fact1[1])=&quot;EDGE&quot;<Font bold="false"> then
            </Font><Font style="Text"> </Font>tam1 := {op(parse(fact1[2]))}; tam2 := {op(parse(fact2[2]))}; 
            if tam1 = tam2 then return true;fi;  
        else  <Font bold="false">
             if evalb(fact1[2]=fact2[2]) then return true;fi;
        fi;     
     fi;</Font>
  
 <Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 2</Font>
  el<Font bold="false">if k1 = 2 then 
     if Is_Equal(fact1,fact2) then return true;      
     elif type(fact1,indexed) and type(fact2,indexed) and 
          Is_Equal(op(0,fact1),op(0,fact2)) and 
          {op(fact1)} = {op(fact2)} then 
         prop:=ObjStruct(convert(op(0,fact1),string))[6] ;         
         prop:=subs(seq([op(parse(ObjStruct(convert(op(0,fact1),string))[1]))][i]=[op(fact1)][i],i=1..nops([op(fact1)])),prop);
         for p in prop do
             if type(p,`=`) and 
              (  [op(lhs(p))]=[op(fact1)]   and [op(rhs(p))]=[op(fact2)] ) or 
              (  [op(rhs(p))]=[op(fact1)]    and [op(lhs(p))]=[op(fact2)] ) then
              return true;
             fi; 
         od;  
     elif type(fact1,function) and op(0,fact1)=`.` and type(fact2,function) and op(0,fact2)=`.` and Unify_Fact(op(1,fact1),op(1,fact2)) and (AttrName(fact1)= AttrName(fact2)or (Unify_Fact(op(1,AttrName(fact1)),op(1,AttrName(fact2)))and op(2,AttrName(fact1))=op(2,AttrName(fact2)) )) then return true;
          
     fi;
 </Font>
 <Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 3</Font>
  el<Font bold="false">if k1 = 3 then
     if Is_Equal(lhs(fact1),lhs(fact2)) and Is_Equal(rhs(fact1),rhs(fact2)) then return true;
     elif Is_Equal(lhs(fact1),rhs(fact2)) and Is_Equal(rhs(fact1),lhs(fact2)) then return true;
     elif Unify_Fact(lhs(fact1),lhs(fact2)) and Is_Equal(rhs(fact1),rhs(fact2)) then 
           return true;
     elif Unify_Fact(lhs(fact1),rhs(fact2)) and Is_Equal(lhs(fact1),rhs(fact2)) then return true;     
     fi; 
  </Font>
 <Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 4</Font><Font style="Text">
   </Font><Font bold="false">elif k1 = 4 then 
     if Unify_Fact(lhs(fact1),lhs(fact2)) and Unify_Fact(rhs(fact1),rhs(fact2)) then return true;
     elif Unify_Fact(lhs(fact1),rhs(fact2)) and Unify_Fact(rhs(fact1),lhs(fact2)) then 
	return 	true;     
     fi;
  </Font><Font style="Text"> </Font>
<Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 5</Font>
  el<Font bold="false">if k1 = 5 then
    if Is_Equal(lhs(fact1)- rhs(fact1) + lhs(fact2) - rhs(fact2),0) then return true;
    elif Is_Equal(lhs(fact1)- rhs(fact1) - lhs(fact2) + rhs(fact2),0) then return true;
    else
       vars1:=Set_Vars(fact1);
       vars2:=Set_Vars(fact2);
       temp:=fact2; 
       for i in vars1 do
          for j in vars2 do
             if Unify_Fact(i,j) then temp:=subs(j=i,temp); fi;
          od;
       od; 
       if temp &lt;&gt; fact2 and Unify_Fact(fact1,temp) then return true;
       fi;        
    fi;

</Font> <Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 6</Font>
  el<Font bold="false">if k1 = 6 then
    if fact1=fact2 then return true;
    else
       #kiem tra kha nang hop nhat khi quan he la doi xung
       return TestDX();
    fi;
   </Font>
 <Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 7: ki\341\273\203m tra s\341\273\261u \304\221\341\273\221i x\341\273\251ng tr\303\252n h\303\240m</Font>
  el<Font bold="false">if k1  = 7 then 
       return Func_DX();         </Font><Font style="Text">
   
</Font> <Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 8:</Font><Font style="Text">
    </Font>el<Font bold="false">if k1 = 8 then
     if(rhs(fact1)-rhs(fact2)=0) then
          return </Font>Unify_Fact(lhs(fact1),lhs(fact2)); <Font style="Text" executable="true" encoding="UTF-8"># G\341\273\215i \304\221\341\273\207 quy: v\341\273\233i lhs(fact1), lhs(fact2) l\303\240 2 s\341\273\261 ki\341\273\207n lo\341\272\241i 7</Font><Font style="Text" executable="true">
</Font><Font bold="false">     fi;
   
 </Font><Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 9:</Font><Font bold="false">
elif k1=9 then 
   if evalb( lhs(fact1) &lt;&gt; lhs(fact2) ) then return false; </Font><Font style="Text" executable="true" encoding="UTF-8"># kh\303\264ng h\341\273\243p nh\341\272\245t \304\221\306\260\341\273\243c</Font><Font bold="false">
   else return Unify_Fact(rhs(fact1),rhs(fact2));fi;</Font>

 <Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 10:</Font>
<Font bold="false">elif k1 = 10 then
    if Unify_Fact(rhs(fact1),rhs(fact2)) and Unify_Fact(lhs(fact1),lhs(fact2)) 
         then return true;fi;
    if Unify_Fact(lhs(fact1),rhs(fact2)) and Unify_Fact(rhs(fact1),lhs(fact2)) 
        then return true;fi;  

</Font><Font style="Text" executable="true" encoding="UTF-8"># N\341\272\277u fact1, fact2 c\303\271ng l\303\240 s\341\273\261 ki\341\273\207n lo\341\272\241i 11:</Font><Font bold="false">
elif k1 =11 then 
     if evalb(fact1 = fact2) then return true;fi;  
  fi;<Font foreground="[255,51,51]">
return false;</Font></Font><Font foreground="[255,51,51]">
</Font><Font foreground="[153,51,255]">end proc:  </Font><Font style="Text" executable="true">#  Unify_Fact</Font></Text-field>
</Input>
</Group>
<Group labelreference="L38">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#--------------------------------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L39">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Unify_In]:=proc(fact, Facts)  </Font><Font style="Text" encoding="UTF-8"># Ki\341\273\203m tra fact c\303\263 trong Facts hay kh\303\264ng theo ngh\304\251a h\341\273\243p nh\341\272\245t?</Font>
<Font bold="false">local i;  
   for i to nops(Facts) do
       if Unify_Fact(fact, Facts[i]) then return i;fi;
   od;  
   return -1; </Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Unify_In</Font></Text-field>
</Input>
</Group>
<Group labelreference="L40">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-----------</Text-field>
</Input>
</Group>
<Group labelreference="L41">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Unify_In1]:=proc(fact, Facts)   </Font><Font style="Text" encoding="UTF-8"># Ki\341\273\203m tra fact c\303\263 trong Facts hay kh\303\264ng theo ngh\304\251a h\341\273\243p nh\341\272\245t?</Font>
<Font bold="false">local i,fact1;
  if  type(fact, set)   then
     for  fact1 in fact  do
          if  not Unify_In1(fact1, Facts)  then  RETURN(false);
        fi;
     end do;
     RETURN(true);
  else
 </Font>
  <Font bold="false"> for i to nops(Facts) do
       if Unify_Fact(fact, Facts[i]) then RETURN(true);fi;
   od;  
   RETURN(false)
 fi;</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Unify_In1</Font></Text-field>
</Input>
</Group>
<Group labelreference="L42">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L43">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Classify_Facts]:=proc(facts::list)</Font>
  <Font style="Text" encoding="UTF-8"># Th\341\273\247 t\341\273\245c xu\341\272\245t ra danh s\303\241ch ch\341\273\251a 11 t\341\272\255p h\341\273\243p t\306\260\306\241ng \341\273\251ng v\341\273\233i 11 lo\341\272\241i s\341\273\261 ki\341\273\207n t\341\273\253 danh s\303\241ch c\303\241c s\341\273\261 ki\341\273\207n ban \304\221\341\272\247u
     #  \304\220\303\243 th\341\273\261c hi\341\273\207n \304\221\341\272\277n lo\341\272\241i sk 8</Font><Font bold="false">
local i,k, Set; 
global <Font foreground="[102,102,102]"> </Font>Fact_Kinds, flag, FactSet;
    Set:={};   <Font foreground="[102,102,102]"> </Font>
      for i in facts do
      k:=Kind_Fact(i);
      if  k&gt;=1 and k&lt;=11  then 
          if not Unify_In1(i,Fact_Kinds[k]) then
              
         <Font foreground="[102,102,102]">     </Font>Fact_Kinds[k]:=<Font foreground="[102,102,102]"> [op(</Font>Fact_Kinds[k]),i];
              FactSet:=FactSet union {i};
              Set:=Set union {i} ;
              flag:=true; 
             fi;    
       fi;   
    od; </Font>
   <Font bold="false">return Set;</Font><Font foreground="[153,51,255]">
end proc:   </Font><Font style="Text" executable="true">#   Classify_Facts</Font></Text-field>
</Input>
</Group>
<Group labelreference="L44">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#--------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L45">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text" encoding="UTF-8"># C\303\241c th\341\273\247 t\341\273\245c t\303\254m ph\341\272\247n giao, hi\341\273\207u, h\341\273\243p c\341\273\247a c\303\241c t\341\272\255p s\341\273\261 ki\341\273\207n, x\303\251t theo ngh\304\251a h\341\273\243p nh\341\272\245t s\341\273\261 ki\341\273\207n.</Font><Font foreground="[153,51,255]">
GRAPH_THEORY[Intersect_Unify] := proc(Aset, Bset)  </Font><Font style="Text" executable="true" encoding="UTF-8"># T\303\254m ph\341\272\247n giao</Font><Font bold="false">
   local  fact, Cset;
   Cset := {};
   for  fact in Aset  do
      if  Unify_In1(fact, Bset)  then  Cset := {op(Cset), fact};fi;
   od;
   return Cset;</Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Text" executable="true">#  Intersect_Unify</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[Minus_Unify]:= proc( Aset, Bset) </Font><Font style="Text" executable="true" encoding="UTF-8"># T\303\254m hi\341\273\207u c\341\273\247a 2 t\341\272\255p s\341\273\261 ki\341\273\207n</Font><Font bold="false">
 return   Aset minus Intersect_Unify(Aset, Bset);   </Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Caption Text" executable="true">#  Minus_Unify</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[Union_Unify] := proc(Aset, Bset)</Font><Font bold="false">   </Font><Font style="Text" executable="true" encoding="UTF-8"># T\303\254m h\341\273\243p c\341\273\247a 2 t\341\272\255p s\341\273\261 ki\341\273\207n</Font><Font bold="false">
   return Aset union Minus_Unify(Bset, Aset);   </Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Text" executable="true">#  Union_Unify</Font>
</Text-field>
</Input>
</Group>
<Group labelreference="L47">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#---------------------</Text-field>
</Input>
</Group>
<Group labelreference="L48">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[IsEqual_Unify]:= proc( expr1, expr2)</Font><Font bold="false"> </Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Caption Text" executable="true">#  IsEqual_Unify</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[Replace_Unify]:= proc( expr)</Font><Font bold="false"> </Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Text" executable="true">#  Replace_Unify</Font></Text-field>
</Input>
</Group>
<Group labelreference="L49">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#--------------------</Text-field>
</Input>
</Group>
<Group labelreference="L50">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Find_VarUnify]:=proc(ex)</Font><Font style="Text">   <Font encoding="UTF-8"># Th\341\273\247 t\341\273\245c: T\303\254m t\341\272\255p h\341\273\243p c\303\241c bi\341\272\277n h\341\273\243p nh\341\272\245t c\303\263 th\341\273\203 thay th\341\272\277 v\341\273\233i nhau</Font>
</Font><Font bold="false">
local i,j,flag1,vars,vars1,thaythe,used;
thaythe:={};
vars1:={}; </Font><Font style="Text" encoding="UTF-8"># vars1 l\306\260u c\303\241c bi\341\272\277n c\341\272\245u tr\303\272c, vars l\306\260u c\303\241c bi\341\272\277n kh\303\264ng c\303\263 c\341\272\245u tr\303\272c</Font><Font bold="false" foreground="[255,51,51]">
vars:=Set_Vars(ex);
used:={};
for i in vars do
    if type(i,indexed)or (type(i,function)and op(0,i)=`.`and type(op(2,i),indexed)) then vars1:={op(vars1),i};vars:=vars minus {i};fi;
od;
vars1:=[op(vars),op(vars1)];
for i in vars1 do
   flag1:=false;
   for j in used do
       if Unify_Fact(i,j) then thaythe:={op(thaythe),i=j};flag1:=true;fi;
   od;
   if not flag1 then used:={op(used),i};fi;
od;
return thaythe;</Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># Find_VarUnify</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[Replace_StructName]:=proc(ex)</Font><Font style="Text">  <Font executable="true" encoding="UTF-8"># Th\341\273\247 t\341\273\245c: Thay th\341\272\277 t\303\252n c\341\272\245u tr\303\272c b\341\272\261ng t\303\252n thu\341\273\231c t\303\255nh. VD: Thay th\341\272\277 Goc[A,B,C] b\341\272\261ng GocB.</Font></Font><Font bold="false" foreground="[255,51,51]">
local vars,thaythe;
vars:=Set_Vars(ex);
thaythe:=map(s-&gt;s=AttrName(s),vars);
return subs(thaythe,ex);</Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Text" executable="true"># Replace_StructName</Font><Font foreground="[153,51,255]">

GRAPH_THEORY[Replace_AttrName]:=proc()</Font><Font style="Text" encoding="UTF-8">  # Th\341\273\247 t\341\273\245c: Thay t\303\252n thu\341\273\231c t\303\255nh b\341\272\261ng t\303\252n c\341\272\245u tr\303\272c. VD: Thay GocB b\341\272\261ng Goc[A,B,C].
</Font><Font foreground="[153,51,255]">
end:  </Font><Font style="Text" executable="true"># Replace_AttrName</Font></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title>
<Text-field style="Heading 2" layout="Heading 2"><Font encoding="UTF-8">\304\220\341\273\215c \304\221\341\273\201 b\303\240i v\303\240 ghi nh\341\272\255n m\303\264 h\303\254nh b\303\240i to\303\241n</Font>
Reset_Onet;
ReadExer;</Text-field></Title>
<Text-field style="Text" layout="Normal"></Text-field>
<Group labelreference="L51">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Reset_Onet] := proc()</Font><Font style="Text" encoding="UTF-8">   #  Th\341\273\247 t\341\273\245c: Kh\341\273\237i t\341\272\241o c\303\241c bi\341\272\277n to\303\240n c\341\273\245c tr\303\252n Onet</Font><Font bold="false">
global
   Hypos,Goals</Font>,<Font bold="false">Objects</Font>,<Font bold="false">Obj_Types</Font>,<Font bold="false">Facts,Fact_Kinds,OAttrs,OAttr_Types,Sol,Params,Funcs,Func_Types,Functions</Font>;<Font bold="false">
   Params:={};
   Objects := [];  Obj_Types := []; 
   OAttrs := [];  OAttr_Types := []; 
   Facts:= {};  <Font foreground="[102,102,102]"> </Font>Fact_Kinds</Font>:<Font bold="false">=[[],[],[],[],[],[],[],[],[],[],[]];
   Hypos := {};  Goals := [];  Sol:= []; Funcs:=[];Func_Types:=[];Functions:={}  ;</Font><Font foreground="[153,51,255]">
end proc: </Font><Font style="Text" executable="true"># Reset_Onet</Font></Text-field>
</Input>
</Group>
<Group labelreference="L52">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#---------------------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L53">
<Input>
<Text-field style="Text" layout="Normal"><Font style="Maple Input" foreground="[153,51,255]">
GRAPH_THEORY[ReadExer]:=proc(url::string)   </Font><Font style="Maple Input" foreground="[0,204,102]"> </Font><Font executable="true" encoding="UTF-8"># Th\341\273\247 t\341\273\245c: \304\220\341\273\215c \304\221\341\273\201 b\303\240i v\303\240 ghi nh\341\272\255n m\303\264 h\303\254nh c\341\273\247a b\303\240i to\303\241n</Font><Font bold="false" style="Maple Input">
 global Hypos,Goals,Params,Objects</Font><Font style="Maple Input">,<Font bold="false">Obj_Types</Font>,<Font bold="false">Facts,Fact_Kinds,OAttrs,OAttr_Types,Funcs,Func_Types,Functions</Font>;<Font bold="false">
 local	line,fd,
        read_objects, read_facts,read_funcs, read_goals,<Font foreground="[255,51,102]">read_params,update;</Font><Font foreground="[153,51,255]">

  update:=proc(ex_vars)</Font><Font foreground="[255,51,51]">
  local vars,i,j;</Font><Font foreground="[153,51,255]">
  </Font>vars :=  <Font foreground="[255,51,51]">ex_vars </Font>minus (convert(Objects, set) 
                union convert(OAttrs, set) union convert(Funcs, set));
     
  for i in vars do           
    if Is_Function(i) then
           if type_Onet(i) = &quot;type?&quot; then next;fi;
           Funcs:= [op(Funcs), i];
           Func_Types:= [op(Func_Types), type_Onet(i)]; 
           for j in [op(i)] do 
              <Font foreground="[255,51,51]"> update(Set_Vars(j));</Font>
           od;    
    elif ValidStructName_Onet(i) and Unify_In1({op(i)},Objects) then
                if type_Onet(i) = &quot;type?&quot; then next;fi;
                Obj_Types:=[op(Obj_Types),type_Onet(i)];
                Objects:=[op(Objects),i]; 
    elif type(i,function) and op(0,i)=`.` and 
         not Unify_In1(op(1,i),Objects)and
         ValidStructName_Onet(op(1,i)) and 
         Unify_In1({op(op(1,i))},Objects) then
                if type_Onet(i) = &quot;type?&quot; then next;fi;
                Obj_Types:=[op(Obj_Types),type_Onet(op(1,i))];
                Objects:=[op(Objects),op(1,i)];          
                OAttrs := [op(OAttrs), i] ;
                OAttr_Types := [op(OAttr_Types), type_Onet(i)];
    else
                if type_Onet(i) = &quot;type?&quot; then next;fi;
 		OAttrs := [op(OAttrs), i] ;
                OAttr_Types := [op(OAttr_Types), type_Onet(i)];
    fi; 
  od;           <Font foreground="[153,51,255]">
 end: </Font></Font></Font><Font executable="true"># update</Font><Font bold="false" style="Maple Input" foreground="[153,51,255]">

 read_params:=proc()</Font><Font bold="false" style="Maple Input" foreground="[102,102,102]">
  </Font><Font bold="false" style="Maple Input" foreground="[255,51,51]"> line := readline(fd);  	  
   while line &lt;&gt; 0 and SearchText(&quot;end_parameters&quot;, line) = 0 do  
     Params:=Params union {parse(line)};
     line := readline(fd);  
   od;    </Font><Font bold="false" style="Maple Input" foreground="[102,102,102]">   </Font><Font bold="false" style="Maple Input" foreground="[153,51,255]">
 end :  </Font><Font executable="true">#  read_params</Font><Font bold="false" style="Maple Input" foreground="[153,51,255]"> 

 read_objects:=proc()</Font><Font bold="false" style="Maple Input" foreground="[102,102,102]">
   </Font><Font bold="false" style="Maple Input" foreground="[255,51,51]">local k,ten1,kieu1,n1;
   line := readline(fd);  	  
   while line &lt;&gt; 0 and SearchText(&quot;end_objects&quot;, line) = 0 do  
     k := SearchText(&quot;:&quot;, line);
     if(k&gt;0)then
             ten1 := [parse( substring(line, 1..(k-1)) )];  n1 := nops(ten1);
             kieu1 := convert(parse(substring(line, k+1..length(line))),string);
            </Font><Font style="Maple Input" foreground="[255,51,51]"> <Font bold="false">Objects := [op(Objects),op(ten1)];
	    </Font> <Font bold="false">Obj_Types:=[op(Obj_Types),kieu1 $ n1];
     fi;
     line := readline(fd);      
   od; </Font></Font><Font bold="false" style="Maple Input" foreground="[153,51,255]">
 end:  </Font><Font executable="true">#  read_objects</Font><Font bold="false" style="Maple Input" foreground="[153,51,255]">

 read_facts:=proc()</Font><Font bold="false" style="Maple Input" foreground="[255,51,51]">
  local k,s,ex_vars,ex;
  line := readline(fd);
  ex_vars := {};
  while line &lt;&gt; 0 and SearchText(&quot;end_facts&quot;, line) = 0 do
  #  print(line);
    s := [parse(line)];
    for  ex in s do       
        k :=  Kind_Fact(ex);
        if  k&gt;=1 and k&lt;=11 and not Unify_In1(ex,Facts)then   
          Facts := {op(Facts), ex};          
          Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex];
          ex_vars := ex_vars union Set_Vars(ex);
        fi;
     od;  
     line := readline(fd);
  od;              
  update(ex_vars);</Font><Font bold="false" style="Maple Input" foreground="[153,51,255]">
 end:   </Font><Font executable="true">#  read_facts</Font><Font bold="false" style="Maple Input" foreground="[153,51,255]">

 read_funcs:=proc()</Font><Font bold="false" style="Maple Input" foreground="[255,51,51]">
  local k,s,ex_vars,ex;
  line := readline(fd); 
  ex_vars := {};   
  while line &lt;&gt; 0 and SearchText(&quot;end_functions&quot;, line) = 0 do
  s := [parse(line)];  
  for  ex in s do</Font><Font bold="false" style="Maple Input">    </Font><Font style="Maple Input" foreground="[255,51,51]">
        </Font><Font bold="false" style="Maple Input">k :=  Kind_Fact(ex);
        if  k&gt;=1 and k&lt;=11 and not Unify_In1(ex,Functions) then   
          Functions := {op(Functions), ex};          
          Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex]; 
          ex_vars := ex_vars union Set_Vars(ex);         
        fi;        
  od;  
  line := readline(fd);
  od; 
  <Font foreground="[255,51,51]">update(ex_vars);</Font><Font foreground="[153,102,255]">
 end: </Font></Font><Font executable="true">#  read_funcs
</Font><Font bold="false" style="Maple Input" foreground="[153,51,255]">
 read_goals:=proc()</Font><Font bold="false" style="Maple Input" foreground="[255,51,51]">
   local s,ex,ex_vars,k;
   line := readline(fd);
   ex_vars := {};
   while line &lt;&gt; 0 and SearchText(&quot;end_goal&quot;, line) = 0  do
      s := [parse(line)];
      for  ex in s  do         
         k :=  Kind_Fact(ex);
         if  (k&gt;=1 and k&lt;=11) or member(ex,Params) and not Unify_In1(ex,Goals) then  
            Goals := [op(Goals), ex];
            ex_vars := ex_vars union Set_Vars(ex);
         fi;
      od;
      line := readline(fd);
  od;
  update(ex_vars); 
 </Font><Font bold="false" style="Maple Input" foreground="[153,51,255]">end: </Font><Font executable="true">#  read_goals</Font>


 # ReadExer's body<Font bold="false" style="Maple Input">
  Reset_Onet();  
  fd := fopen(url, READ, TEXT);
  line := readline(fd);
  while line &lt;&gt; 0 and SearchText(&quot;begin_exercise&quot;, line) = 0  do
     line := readline(fd);
  od; 
 </Font><Font style="Maple Input"> <Font bold="false">while line &lt;&gt; 0 and SearchText(&quot;end_exercise&quot;, line) = 0  do
    line := readline(fd);
   <Font foreground="[255,51,102]"> while line &lt;&gt; 0 and SearchText(&quot;begin_hypothesis&quot;, line) = 0 and 
            SearchText(&quot;end_exercise&quot;, line) = 0 do
         line := readline(fd);
    od;</Font></Font></Font>  <Font bold="false" style="Maple Input" foreground="[255,51,102]">
    if  SearchText(&quot;end_exercise&quot;, line) &gt; 0 then  
        fclose(fd);
        return(NULL);   
    fi;
    line := readline(fd);
   </Font><Font bold="false" style="Maple Input" foreground="[255,51,51]"> while line &lt;&gt; 0 and SearchText(&quot;end_hypothesis&quot;, line) = 0 do
        if(SearchText(&quot;parameters:&quot;, line)&gt;0  )then read_params();                
	elif(SearchText(&quot;objects:&quot;, line)&gt;0  )then read_objects();      
        elif(SearchText(&quot;facts:&quot;, line)&gt;0 )then read_facts();
        elif(SearchText(&quot;functions:&quot;, line)&gt;0 )then read_funcs() ;   
	fi;
        line := readline(fd);          
    od;
    Hypos:= Facts union Functions;
  </Font>  
<Font encoding="UTF-8">     # \304\220\341\273\215c ph\341\272\247n goal</Font><Font bold="false" style="Maple Input" foreground="[255,51,51]">
    line := readline(fd);
    while line &lt;&gt; 0 and SearchText(&quot;begin_goal&quot;, line) = 0 do
         line := readline(fd);
    od;
   # trace(read_goals);
    read_goals();</Font><Font bold="false" style="Maple Input">
    line := readline(fd);
  od;</Font><Font style="Maple Input">
  <Font bold="false">fclose(fd);
  #print(&quot;da dong file&quot;);
</Font><Font foreground="[153,51,255]">end proc: </Font></Font><Font executable="true">#end ReadExer</Font></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title>
<Text-field style="Heading 2" layout="Heading 2"><Font encoding="UTF-8">Gi\341\272\243i b\303\240i to\303\241n
</Font>ApplyRule; Find_FuncStruct; MyCombinat;
ReplaceR; Get_Values; Compute_Func;
Deduce_From3; Deduce_From3s;
Deduce_Object; Deduce_Objects;
Deduce_From453s;
Deduce_Funcs; Deduce_Rules;</Text-field></Title>
<Text-field style="Text" layout="Normal"></Text-field>
<Group labelreference="L54">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[ApplyRule] := proc(rule, FactSet)</Font><Font style="Text" encoding="UTF-8"> # Th\341\273\247 t\341\273\245c: \303\201p d\341\273\245ng rule tr\303\252n t\341\272\255p FactSet
</Font><Font bold="false">local  fact, setfact;
   if  Unify_In1(rule[4][1], FactSet)  then  </Font><Font style="Text" encoding="UTF-8"># Gi\341\272\243 thi\341\272\277t n\341\272\261m trong t\341\272\255p FactSet</Font><Font bold="false">
      setfact := {};
      for  fact in rule[4][2]  do 
         if not Unify_In1(fact,  FactSet)  then  setfact := {op(setfact), fact};</Font><Font style="Text" encoding="UTF-8"> #  K\341\272\277t lu\341\272\255n kh\303\264ng n\341\272\261m trong t\341\272\255p FactSet</Font><Font bold="false">
         fi;
      od;
      RETURN (setfact);
   else  RETURN ({});
   fi;</Font><Font foreground="[153,51,255]">
end proc: </Font><Font style="Text" executable="true">#  ApplyRule</Font><Font foreground="[153,51,255]"> </Font></Text-field>
</Input>
</Group>
<Group labelreference="L55">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------</Text-field>
</Input>
</Group>
<Group labelreference="L56">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Find_FuncStruct]:=proc(func) </Font><Font style="Text" encoding="UTF-8">#  Th\341\273\247 t\341\273\245c: T\303\254m c\341\272\245u tr\303\272c c\341\273\247a func</Font><Font bold="false">
local i;
   for i in Func_Structs do
       if evalb(func[2]=convert(op(0,parse(i[1])),string)) and 
          func[3] = i[2][2] then return i;fi; 
   od;</Font><Font foreground="[153,51,255]">
end proc: </Font><Font style="Text" executable="true"># Find_FuncStruct</Font></Text-field>
</Input>
</Group>
<Group labelreference="L57">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#--------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L58">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[MyCombinat]:=proc(doiso::list, Fact)</Font><Font style="Text" encoding="UTF-8">  # Th\341\273\247 t\341\273\245c: X\303\251t c\303\241c t\341\273\225 h\341\273\243p c\303\263 th\341\273\203 c\303\263 t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 2 v\303\240 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 7
</Font><Font bold="false">local TH_Obj, n, i, ToHop, k,Otemp,fact,
      TestCombinat;   
   
    <Font foreground="[153,51,255]">TestCombinat := proc(th,tohop)  </Font></Font><Font style="Text" executable="true" encoding="UTF-8"># Th\341\273\247 t\341\273\245c con: Ki\341\273\203m tra th c\303\263 trong tohop hay ch\306\260a?</Font><Font bold="false" foreground="[153,51,255]"> </Font><Font style="Text" encoding="UTF-8">VD: th = [1,2], tohop = [[2,1],[3,4]] --&gt;th thuoc tohop l\303\240 true</Font><Font bold="false">
       local j;
       for j to nops (tohop) do
           if {op(tohop[j])} =  {op(th)} then return true;fi;  
       od;  
       return false; 
   <Font foreground="[153,51,255]"> end: </Font></Font><Font style="Text" executable="true"># TestCombinat</Font><Font style="Text" foreground="[51,153,0]">

<Font bold="true"># MyCombinat's body</Font></Font><Font bold="false">
   n:=nops(doiso);Otemp:=[];
   for fact in Fact do
      if member(type_Onet(fact,1),doiso) then  
        Otemp:=[op(Otemp),fact];fi;
   od;
   TH_Obj:= combinat[permute](Otemp,n);   
   ToHop:=[]; 
   for i to nops(TH_Obj) do
       if doiso = Find_Fact_Types(TH_Obj[i],1) and nops(TH_Obj[i]) = nops({op(TH_Obj[i])}) then    
           if nargs=3 then 
              if not TestCombinat(TH_Obj[i],ToHop) then   
	          ToHop:=[op(ToHop),TH_Obj[i]];fi;
           else ToHop:=[op(ToHop),TH_Obj[i]];fi;
       fi;
   od;
  return ToHop;</Font><Font foreground="[153,51,255]">
end proc:   </Font><Font style="Text" executable="true">#  MyCombinat</Font></Text-field>
</Input>
</Group>
<Group labelreference="L59">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L60">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[ReplaceR]:=proc(comb::list,rule)</Font><Font bold="false">
local j, rerule;
rerule:= subs(seq(rule[2][i]=comb[i],i=1..nops(comb)),rule);
for j in rerule[4][1] do	
     if Kind_Fact(j) = 1 then 	   
	rerule:=subs(j[2]=convert(subs(seq(rule[2][i]=comb[i],i=1..nops(comb)),parse(j[2])), string),rerule);
     fi;
od;<Font foreground="[255,51,102]">
return rerule;</Font></Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  ReplaceR</Font></Text-field>
</Input>
</Group>
<Group labelreference="L61">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L62">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font><Font foreground="[153,102,255]">Get_Values]:=proc(biens)</Font><Font style="Text" encoding="UTF-8">  # Th\341\273\247 t\341\273\245c t\303\254m gi\303\241 tr\341\273\213 c\341\273\247a biens, biens c\303\263 th\341\273\203 c\303\263 nhi\341\273\201u gi\303\241 tr\341\273\213
</Font><Font bold="false">local get_value,giatridon,cacgiatridon,tachgiatri,
      bien, values;
global Fact_Kinds, Obj_Types;

   <Font foreground="[153,102,255]">get_value:= proc(bien)  </Font></Font><Font style="Text" executable="true" encoding="UTF-8"># Th\341\273\247 t\341\273\245c con: T\303\254m gi\303\241 tr\341\273\213 c\341\273\247a bi\341\272\277n. VD: bien:=a;</Font><Font bold="false">
     </Font><Font style="Text" encoding="UTF-8"> # N\341\272\277u a c\303\263 gi\303\241 tr\341\273\213 c\341\273\245 th\341\273\203 (sk3,sk8) th\303\254 --&gt;gi\303\241 tr\341\273\213
             # N\341\272\277u a thu\341\273\231c sk2 hay sk7 v\303\240 kh\303\264ng c\303\263 gi\303\241 tr\341\273\213 c\341\273\245 th\341\273\203 th\303\254 --&gt;&quot;xd&quot;</Font><Font style="Text">
<Font encoding="UTF-8">             # N\341\272\277u a kh\303\264ng thu\341\273\231c sk2, sk3, sk7, sk8 --&gt; &quot;cxd&quot;
             # N\341\272\277u a c\303\263 nhi\341\273\201u gi\303\241 tr\341\273\213 --&gt; t\341\272\255p gi\303\241 tr\341\273\213. VD: (a = 2, a = 3)---&gt; {2,3}</Font></Font><Font bold="false">
      local fact, value, j;
      value:= {}; 
      if Unify_In1(bien,[op(Fact_Kinds[2]),op(Fact_Kinds[7])]) then
         value:= value union {&quot;xd&quot;}; 
      fi;
      for fact in [op(Fact_Kinds[3]),op(Fact_Kinds[8])] do
         if Unify_Fact(AttrName(bien) , lhs(fact)) then
             value:= value union {rhs(fact)};
         fi;
      od; 
      </Font><Font style="Text" encoding="UTF-8"># T\303\254m gi\303\241 tr\341\273\213 c\341\273\247a d khi bi\341\272\277t d.f</Font><Font bold="false">
      if member(type_Onet(bien),Obj_Types) and value ={&quot;xd&quot;} then
        for j to nops(Fact_Kinds[2]) do
           if not evalb(bien = Fact_Kinds[2][j]) and 
              Is_DacTrung({Fact_Kinds[2][j]},bien) and type_Onet(Fact_Kinds[2][j])=&quot;PTDT_TQ&quot;  then  	     
		 value := value union {get_value(Fact_Kinds[2][j])};
           fi;
        od; 
      fi;
      </Font><Font style="Text">#------------------------</Font><Font bold="false">
      if nops(value) &gt;=2 and member(&quot;xd&quot;,value) then
         value := value minus {&quot;xd&quot;}; 
      fi;
      if nops(value) = 0 then return &quot;cxd&quot;;
      elif nops(value) = 1 then return op(value);
      else return value;fi;
   <Font foreground="[153,102,255]">end: </Font></Font><Font style="Text" executable="true"># get_value</Font><Font style="Text">

       </Font><Font bold="false" foreground="[153,102,255]">giatridon:=proc(giatri)   </Font><Font style="Text" executable="true" encoding="UTF-8"># Th\341\273\247 t\341\273\245c con: Ki\341\273\203m tra giatri c\303\263 ph\341\272\243i l\303\240 gi\303\241 tr\341\273\213 \304\221\306\241n hay kh\303\264ng?</Font><Font bold="false">
      </Font><Font style="Text" encoding="UTF-8"># N\341\272\277u giatri kh\303\264ng l\303\240 gi\303\241 tr\341\273\213 \304\221\306\241n th\303\254 --&gt; v\341\273\213 tr\303\255 
              # VD: giatri: =[1,2,{3,4}] l\303\240 gi\303\241 tr\341\273\213 ph\341\273\251c --&gt; return 3;  
              # VD: giatri:= [1,2,3] l\303\240 gi\303\241 tr\341\273\213 \304\221\306\241n ---&gt; return 0;</Font><Font bold="false">  
      local i;
      for i to nops(giatri) do 
          if type(giatri[i],`set`) then return i;fi;
      od;
      return 0;</Font>
   <Font bold="false" foreground="[153,102,255]">end: </Font><Font style="Text" executable="true"># giatridon</Font>  

   <Font bold="false" foreground="[102,102,255]">cacgiatridon:= proc(giatri) </Font><Font style="Text" executable="true" encoding="UTF-8"># Th\341\273\247 t\341\273\245c con: Ki\341\273\203m tra giatri c\303\263 ph\341\272\243i l\303\240 c\303\241c gi\303\241 tr\341\273\213 \304\221\306\241n hay kh\303\264ng?</Font><Font bold="false">
      local gt;
      for gt in giatri do
         if giatridon(gt) &lt;&gt; 0 then return false;fi;
      od; 
      return true;</Font>
   <Font bold="false" foreground="[153,102,255]">end : </Font><Font style="Text" executable="true"># cacgiatridon</Font>

   <Font bold="false" foreground="[153,102,255]">tachgiatri:= proc(giatri)   </Font><Font style="Text" executable="true" encoding="UTF-8"># Th\341\273\247 t\341\273\245c con: T\303\241ch giatri ph\341\273\251c th\303\240nh 1 danh s\303\241ch c\303\241c gi\303\241 tr\341\273\213 \304\221\306\241n</Font><Font bold="false">
      </Font><Font style="Text" encoding="UTF-8"># VD: N\341\272\277u giatri:=[1,2,{3,4}]---&gt;giatri:=[[1,2,3],[1,2,4],[1,2,3,4]]</Font><Font bold="false">
      local k,i, temp, seq1, seq2, giatritemp;
      giatritemp:=giatri; 
      while not cacgiatridon(giatritemp) do
	 for i to nops(giatritemp) do
            k := giatridon(giatritemp[i]);
            if k &lt;&gt; 0 then
             seq1:= seq(giatritemp[i][j],j=1..k-1);
             seq2:= seq(giatritemp[i][j],j=k+1..nops(giatritemp[i]));
             temp:=map(s-&gt;[seq1,s,seq2],giatritemp[i][k]);
             giatritemp:= subs(giatritemp[i]=op(temp),giatritemp);
             break;
            fi; 
         od; 
      od;  
      return giatritemp;
   <Font foreground="[153,102,255]">end: </Font></Font><Font style="Text" executable="true"># tachgiatri</Font><Font style="Text">

# Get_Values's body</Font><Font bold="false">
if type(biens,`list`) then </Font><Font style="Text" encoding="UTF-8"># T\303\254m gi\303\241 tr\341\273\213 c\341\273\247a nhi\341\273\201u bi\341\272\277n c\303\271ng l\303\272c</Font><Font bold="false">
   values:= [];
   for bien in biens do
      values:= [op(values),get_value(bien)];
   od;
   </Font><Font style="Text" encoding="UTF-8"># N\341\272\277u trong values c\303\263 gi\303\241 tr\341\273\213 ph\341\273\251c th\303\254 t\303\241ch th\303\240nh c\303\241c gi\303\241 tr\341\273\213 \304\221\306\241n
</Font><Font style="Text">       # VD: values:=[1,2,{3,4}]---&gt;values:=[[1,2,3],[1,2,4],[1,2,3,4]]</Font><Font bold="false">
   if giatridon(values) &lt;&gt; 0 then
      values:= {op(tachgiatri([values]))};
   fi;
else </Font><Font style="Text" encoding="UTF-8"># T\303\254m gi\303\241 tr\341\273\213 c\341\273\247a m\341\273\231t bi\341\272\277n</Font><Font bold="false">
   values:= get_value(biens);
fi; 
return values;</Font><Font foreground="[153,102,255]">
end: </Font><Font style="Text" executable="true"># Get_Values</Font></Text-field>
</Input>
</Group>
<Group labelreference="L63">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#----------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L64">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Compute_Func]:=proc(func,bien,giatri,tri)</Font>
  <Font style="Text" encoding="UTF-8"># Th\341\273\247 t\341\273\245c: \304\220\341\273\215c c\341\272\245u tr\303\272c c\341\273\247a func \304\221\341\273\203 t\303\255nh gi\303\241 tr\341\273\213 c\341\273\247a h\303\240m v\341\273\233i \304\221\341\273\221i s\341\273\221 truy\341\273\201n v\303\240o l\303\240 bi\341\272\277n</Font><Font bold="false">
local funcname, temp, gt, thaythe,i,ketqua,
      tinhgiatri ;
global ObjsNew, OTypesNew, FactsNew,chiso;
      </Font><Font style="Text">  
      </Font><Font bold="false" foreground="[153,102,255]">tinhgiatri:= proc(gt, n)</Font><Font bold="false">
   local result, gtt;
     result:={}; 

     </Font><Font style="Text" encoding="UTF-8">#  N\341\272\277u trong giatri c\303\263 &quot;xd&quot; th\303\254 kh\303\264ng c\341\272\247n t\303\255nh h\303\240m -&gt; h\303\240m \304\221\303\243 x\303\241c \304\221\341\273\213nh</Font>
     <Font bold="false">if member(&quot;xd&quot;,gt) then 
       result:={subs(thaythe,parse(temp[1]))}; 
       if func[3] &lt;&gt; [] then
           if n = 4 then
              if evalb(temp[3][2]=&quot;DUONGTHANG&quot;) then temp[3]:= subs(temp[3][1]=parse(cat(temp[3][1],&quot;.f&quot;)),temp[3]);fi;
              result:=result union {temp[3][1],op(temp[5])};
           else
              ObjsNew:=[op(ObjsNew),temp[3][1]];
              OTypesNew:=[op(OTypesNew),temp[3][2]];
              FactsNew:=[op(FactsNew),temp[3][1],op(temp[5])];
           fi; 
       fi;
     else </Font><Font style="Text" encoding="UTF-8"># c\303\263 gi\303\241 tr\341\273\213 x\303\241c \304\221\341\273\213nh</Font><Font bold="false">
       gtt:= funcname(op(gt)); 
       if gtt &lt;&gt; NULL then	
          result:={subs(thaythe,parse(temp[1])) = gtt};
          if func[3] &lt;&gt; [] then
            if n = 4 then
              if evalb(temp[3][2]=&quot;DUONGTHANG&quot;)or evalb(temp[3][2]=&quot;DOAN&quot;) then temp[3]:= subs(temp[3][1]=parse(cat(temp[3][1],&quot;.f&quot;)),temp[3]);fi; 
              result:=result union {temp[3][1]= gtt,op(temp[5])};
            else
               ObjsNew:=[op(ObjsNew),temp[3][1]];
               OTypesNew:=[op(OTypesNew),temp[3][2]];
               FactsNew:=[op(FactsNew),temp[3][1]= gtt,op(temp[5])];
            fi; 
          fi;
          result:= result union {subs(thaythe,parse(temp[1]))};
       fi;  
    fi;
    return result; </Font>  <Font style="Text">
      </Font><Font bold="false" foreground="[153,102,255]">end: </Font><Font style="Text" executable="true"># tinhgiatri</Font><Font style="Text">
  
# Compute_Func's body
<Font encoding="UTF-8">       # Thay th\341\272\277 bi\341\272\277n v\303\240o h\303\240m \304\221\341\273\203 t\303\255nh gi\303\241 tr\341\273\213 c\341\273\247a h\303\240m</Font></Font><Font bold="false">
 # trace(tinhgiatri);
   thaythe:={};
   for i to nops(bien) do
      thaythe:= thaythe union {func[2][1][i] = bien[i]};od;
   if func[3] &lt;&gt; [] then
      if nargs = 4 then 
         thaythe:=thaythe union {func[3][1] = tri};
      else
        thaythe:= thaythe union {func[3][1] = cat(func[3][1],chiso)};
        chiso:= chiso+1;
      fi; 
   fi;
   temp:= subs(thaythe,func);
  
   funcname:=parse(func[4]); 
  
   </Font><Font style="Text" encoding="UTF-8"># N\341\272\277u gi\303\241 tr\341\273\213 c\341\273\247a bi\341\272\277n nhi\341\273\201u h\306\241n 1</Font><Font bold="false">
   ketqua := {}; 
   if type(giatri,`set`) then
      for gt in giatri do
         ketqua := ketqua union {tinhgiatri(gt, nargs)};
      od; 
   else
      ketqua := tinhgiatri(giatri,nargs);
   fi;
   return ketqua;</Font><Font foreground="[153,51,255]">  
end proc: </Font><Font style="Text" executable="true"># Compute_Func</Font></Text-field>
</Input>
</Group>
<Group labelreference="L65">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#----------------<Font bold="true" style="Text">
</Font></Text-field>
</Input>
</Group>
<Group labelreference="L76">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[SolveFact] := proc(fact, vars::set) </Font><Font foreground="[0,204,0]"># chua dung den</Font><Font style="Text">
<Font encoding="UTF-8"># Th\341\273\247 t\341\273\245c: Gi\341\272\243 fact thu\341\273\231c sk3, 4, 5 \304\221\341\273\203 t\303\255nh thu\341\273\231c t\303\255nh v\341\272\277 tr\303\241i ho\341\272\267c t\303\255nh theo thu\341\273\231c t\303\255nh \304\221\306\260\341\273\243c ghi trong t\341\272\255p vars v\341\273\233i \304\221i\341\273\201u ki\341\273\207n l\303\240:  fact ph\341\272\243i thu\341\273\231c s\341\273\261 ki\341\273\207n lo\341\272\241i 3, 4 hay 5</Font></Font><Font bold="false">
local  expr, list1;
   if  nargs = 3  then  
      expr := simplify(dongian_ptO(fact));  list1 := MySolve( expr, vars);
   else list1 := [MySolve(fact, SetVars(lhs(fact), nameO) )];
   fi;
   if  list1 = {}  then  RETURN (NULL);
   fi;
   RETURN (list1[1]);</Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># SolveFact</Font></Text-field>
</Input>
</Group>
<Group labelreference="L77">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------------</Text-field>
</Input>
</Group>
<Group labelreference="L78">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Test] := proc(fact)</Font><Font foreground="[0,255,0]"># chua dung den</Font><Font bold="false">
 </Font><Font style="Text" executable="true" encoding="UTF-8"># Th\341\273\247 t\341\273\245c: Ki\341\273\203m tra s\341\273\261 m\303\242u thu\341\272\253n c\341\273\247a s\341\273\261 ki\341\273\207n m\341\273\227i lo\341\272\241i = v\341\273\233i nh\341\273\257ng s\341\273\261 ki\341\273\207n \304\221\303\243 c\303\263.</Font><Font style="Text" encoding="UTF-8"> VD: a = 2*c  v\303\240  a = sqrt(3)*c </Font><Font style="Text">  </Font><Font bold="false">
local  expr, fact1, vars1, vars,f;
   if  type(fact, set) or type(fact, list)  then
      for  f in fact  do
         if  Test(f) = false  then  RETURN(false);
         fi;
      od;
   fi;
   if  not type(fact, `=`) then  RETURN(true);
   fi;
   vars := Set_Vars(fact);
   if  nops(vars) &lt;&gt; 2  then  RETURN(true);
   fi;
   for  fact1 in {op(Fact_Kinds[4]),op(Fact_Kinds[5])}  do
      vars1 :=  Set_Vars(fact1);
      if  nops(vars1) = 2 and Unify_in(vars, vars1) and 
          MySolve({fact, fact1}, vars) = {}  then   RETURN(false);
      fi;
   od;
   </Font><Font style="Text" encoding="UTF-8"># Kh\303\264ng ph\303\241t hi\341\273\207n th\341\272\245y m\303\242u thu\341\272\253n</Font><Font bold="false">
   RETURN (true);</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Test</Font>
</Text-field>
</Input>
</Group>
<Group labelreference="L79">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#---------------<Font style="Text" size="24">
# Deduce</Font></Text-field>
</Input>
</Group>
<Group labelreference="L80">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_From3]:=proc(fact3)</Font><Font style="Text">
<Font encoding="UTF-8"># Sinh 1 s\341\273\261 ki\341\273\207n lo\341\272\241i 2 t\341\273\253 1 s\341\273\261 ki\341\273\207n lo\341\272\241i 3. N\341\272\277u nhi\341\273\201u sk3 c\303\271ng sinh m\341\273\231t sk2 th\303\254 s\341\272\275 gom ch\303\272ng v\303\240o m\341\273\231t b\306\260\341\273\233c gi\341\272\243i trong Sol. VD: {a = 2, a =3} c\303\271ng sinh ra {a} n\303\252n ta c\303\263 [&quot;Deduce_From3s&quot;,[],{a = 2, a =3}, {a}].</Font></Font><Font bold="false">
local fact2,i;
global Fact_Kinds, FactSet, Sol, flag; 
   fact2:=lhs(fact3);
   if not Unify_In1(fact2, Fact_Kinds[2]) then 
      Fact_Kinds[2]:=[op(Fact_Kinds[2]),fact2];
      FactSet:=FactSet union {fact2};
      <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_From3s&quot;,[],{fact3},{fact2}]];</Font>
   else
      for i to nops(Sol) do
         if Sol[i][1] = &quot;Deduce_From3s&quot; and Sol[i][4] = {fact2} then
            <Font opaque="true" background="[204,204,204]">Sol[i][3]:= Sol[i][3] union {fact3};</Font>
         fi;
      od; 
   fi;  
   flag:= true;  </Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Deduce_From3</Font></Text-field>
</Input>
</Group>
<Group labelreference="L81">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L82">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_From3s]:=proc()  </Font><Font style="Text" encoding="UTF-8"># Th\341\273\247 t\341\273\245c: Sinh ra c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 2 t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 3</Font> 
<Font bold="false">local fact3;
global Fact_Kinds, DF3;  
   for fact3 in Fact_Kinds[3] do
      if not member(fact3, DF3) then
         Deduce_From3(fact3);
         DF3:= DF3 union {fact3};
      fi;
   od;<Font foreground="[255,51,51]">
return [</Font>Fact_Kinds,Sol]<Font foreground="[255,51,51]">;</Font></Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Deduce_From3s</Font></Text-field>
</Input>
</Group>
<Group labelreference="L83">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L84">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_From8]:=proc(fact8)</Font><Font style="Text">
<Font encoding="UTF-8"># Sinh 1 sk7 t\341\273\253 1 sk8. N\341\272\277u c\303\263 nhi\341\273\201u sk8 c\303\271ng sinh ra 1 sk7 th\303\254 s\341\272\275 gom ch\303\272ng v\303\240 m\341\273\231t b\306\260\341\273\233c gi\341\272\243i trong Sol. 
# VD: {VECTO(A,B) = [2,3], VECTO(A,B) =[4,5]} c\303\271ng sinh ra {VECTO(A,B)} n\303\252n ta c\303\263 
</Font>#      [&quot;Deduce_From8s&quot;,[],{VECTO(A,B) = [2,3], VECTO(A,B) =[4,5]}, {VECTO(A,B)}].</Font><Font bold="false">
local fact7,i;
global Fact_Kinds, FactSet,Sol,flag;
   fact7:=lhs(fact8);
   if not Unify_In1(fact7, Fact_Kinds[7]) then        
	Fact_Kinds[7]:=[op(Fact_Kinds[7]),fact7];
     FactSet:=FactSet union {fact7}; 
     <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_From8s&quot;,[],{fact8},{fact7}]];</Font>
   else
      for i to nops(Sol) do
        if Sol[i][1] = &quot;Deduce_From8s&quot; and Sol[i][4] = {fact7} then
            <Font opaque="true" background="[204,204,204]">Sol[i][3]:= Sol[i][3] union {fact8};</Font>
         fi;
      od; 
   fi;  
   flag:=true;  </Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Deduce_From8</Font></Text-field>
</Input>
</Group>
<Group labelreference="L85">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#----------------------</Text-field>
</Input>
</Group>
<Group labelreference="L86">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_From8s]:=proc()</Font>
   <Font style="Text" encoding="UTF-8"># Th\341\273\247 t\341\273\245c: Sinh c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 7 t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 8.</Font><Font bold="false">
local fact8;
global Fact_Kinds, DF8;  
   for fact8 in Fact_Kinds[8] do
      if not member(fact8,DF8) then
         Deduce_From8(fact8);
         DF8:= DF8 union {fact8};
      fi;
   od;<Font foreground="[255,51,51]">
return [</Font>Fact_Kinds,Sol]<Font foreground="[255,51,51]">;</Font></Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#   Deduce_From8s</Font></Text-field>
</Input>
</Group>
<Group labelreference="L87">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-----------------------</Text-field>
</Input>
</Group>
<Group labelreference="L88">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" underline="true" background="[255,204,0]" italic="true" foreground="[153,51,255]">GRAPH_THEORY[Deduce_Object]:=proc(d,Goal)</Font><Font underline="true" italic="true" foreground="[255,51,51]">
</Font><Font foreground="[255,51,51]">local ObjStructTemp,thaythe,FK2,FK3,FK45,
<Font encoding="UTF-8">      Deduce_ObjRules,Deduce_ObjProp,Deduce_OConstructRela,Deduce_ObjRela1,Deduce_ObjRela21,Deduce_ObjRela22,Deduce_ObjRela3,Deduce_ObjFunc, replace;\134
</Font>
global Fact_Kinds,FactSet,Sol,flag,TestOR,TestOCR,TestProp;

ObjStructTemp:=ObjStruct_Replace(d);</Font><Font foreground="[153,51,255]">

replace:=proc()</Font><Font foreground="[255,51,51]">
thaythe:=Find_VarUnify({op(Fact_Kinds[2])});
FK2:=Replace_StructName(subs(thaythe,{op(Fact_Kinds[2])}));
FK3:=Replace_StructName(subs(thaythe,{op(Fact_Kinds[3])}));
FK45:=Replace_StructName(subs(thaythe,{op(Fact_Kinds[4]),op(Fact_Kinds[5])}));</Font><Font foreground="[153,51,255]">
end: </Font><Font bold="true" style="Text" executable="true"># replace</Font><Font foreground="[153,51,255]">

Deduce_ObjProp:=proc()</Font><Font foreground="[255,51,51]">
local prop,k,news;
news:={};
for prop in ObjStructTemp[6] do    
  k:=Kind_Fact(prop);
  if k&gt;=1 and k&lt;=11 and not Unify_In1(prop,Fact_Kind[k]) then
     news:={op(news),prop};
     Fact_Kinds[k] :=[op(Fact_Kinds[k]),prop];
  fi;
od;
if news&lt;&gt;{} then 
 FactSet:=FactSet union news; 
 <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_ObjProp&quot;,[],{},news]]; </Font>
fi;
TestProp:={op(TestProp),d};</Font><Font foreground="[153,51,255]">
end:  </Font><Font bold="true" style="Text" executable="true"># Deduce_ObjProp</Font><Font foreground="[153,51,255]">

Deduce_OConstructRela:=proc()</Font><Font foreground="[255,51,51]">
local i,f,expr,the,bthe, k,vars;
the:={};bthe:={};

for f in ObjStructTemp[5] do
  if member([d,f],TestOCR) then next;fi; 
    vars:=Set_Vars(f);
    for i in vars do
       if type(i,function)and op(0,i)&lt;&gt;`.` then vars:=vars minus {i} union Set_Vars(op(i));fi;
    od;
  for i in vars do
<Font encoding="UTF-8">     if type(i,function)and op(0,i)=`.` and member(op(1,i),ObjStructTemp[2][1],'k')and type(parse(ObjStruct(ObjStructTemp[2][2][k])[1]),indexed) and member(op(1,i),FK2) and not type (Get_Values(op(1,i)), string) then \134
</Font>       bthe:={op(bthe), op(1,i)= Get_Values(op(1,i))};
       if op(2,i)=x then the:={op(the),i=Get_Values(op(1,i))[1]};
       elif op(2,i)=y then the:={op(the),i=Get_Values(op(1,i))[2]};
       fi;        
     fi;
   od;

if the&lt;&gt;{} then 
   expr:=subs(the,f); 
   if Set_Vars(rhs(expr))   = {} then              
   k :=  Kind_Fact(expr);
   if  k&gt;=1 and k&lt;=11 and not Unify_In1(expr,FactSet) then
        Fact_Kinds[k] :=[op(Fact_Kinds[k]),expr];
        FactSet:=FactSet union {expr};
        <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_OConstructRela&quot;,[f],bthe,{expr}]]; </Font>
        TestOCR:= TestOCR union {[d,f]};  
        flag:=true;       
   fi;  fi; 
fi;
od;</Font><Font foreground="[153,51,255]">
end: </Font><Font bold="true" style="Text" executable="true"># Deduce_OConstructRela</Font><Font foreground="[153,51,255]">
<Font underline="true">
</Font><Font italic="true">Deduce_ObjRela1:=proc()</Font></Font><Font italic="true" foreground="[255,51,51]">
local f,vars,fact,expr,news,ex,k, t;

for f in ObjStructTemp[7] do 
 if member([d,f],TestOCR) then next;fi; 
 vars:=`minus`(f[3],FK2);
 if (f[2]=1 and nops(vars)=1) or (f[2]=0 and vars=f[5]) then    
    expr:=subs(FK3,f[6]);    
    news:=MySolve(expr,vars,1);
</Font><Font bold="true" style="Text" executable="true" italic="true"># </Font><Font bold="true" style="Text" encoding="UTF-8" italic="true">news c\303\263 th\341\273\203 l\303\240{}, hay c\303\263 nhi\341\273\201u nghi\341\273\207m nh\306\260 {{a=1,b=3},{a=2,b=4}}. N\341\272\277u c\303\263 nhi\341\273\201u nghi\341\273\207m th\303\254 ch\341\273\215n 1 nghi\341\273\207m ng\341\272\253u nhi\303\252n</Font><Font italic="true" foreground="[255,51,51]">
    if news&lt;&gt;{}then
       TestOCR:= TestOCR union {[d,f]};            
       for ex in news[1] do             
          k :=  Kind_Fact(ex);
          if  k&gt;=1 and k&lt;=11 and evalb(ex) = false and not Unify_In1(ex,FactSet) then
              Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex];
              FactSet:=FactSet union {ex};
          fi;
       od;
       t:=f[3] minus vars;               
      <Font opaque="true" background="[204,204,204]"> Sol:=[op(Sol),[&quot;Deduce_ObjRela1&quot;,f,{seq(t[i]= Get_Values(t[i]), i = 1..nops(t))},news[1]]];</Font>
       flag:=true;             
     fi;           
 fi;
od;                </Font><Font italic="true" foreground="[153,51,255]">
end:  </Font><Font bold="true" style="Text" executable="true" italic="true"># Deduce_ObjRela1</Font><Font italic="true" foreground="[153,51,255]"> 

Deduce_ObjRela21:=proc()</Font><Font italic="true" foreground="[255,51,51]">
local f,vars,fact,expr,news,ex,k,t;
for f in ObjStructTemp[7] do    
   if member([d,f],TestOCR) then next;fi;  
   vars:=`minus`(f[3],FK2);
   if nops(vars)=2 then
    for fact in FK45 minus DF53 minus DF43 do
      if `minus`(Set_Vars(fact),FK2) = vars then      
          expr:=subs(FK3,{f[6],fact});
          news:={};    
          if nops(expr)=2 then news:=MySolve(expr,vars,1);fi;          
          if news&lt;&gt;{}then 
              TestOCR:= TestOCR union {[d,f]};       
              for ex in news[1] do             
                 k :=  Kind_Fact(ex);
                 if  k&gt;=1 and k&lt;=11 and evalb(ex) = false and not Unify_In1(ex,FactSet) then

                       Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex];
                       FactSet:=FactSet union {ex};
                 fi;
              od;
              t:= f[3] union Set_Vars(fact) minus vars;              
             <Font opaque="true" background="[204,204,204]"> Sol:=[op(Sol),[&quot;Deduce_ObjRela21&quot;,f,{fact} union {seq(t[i]=Get_Values(t[i]), i = 1..nops(t))} ,news[1]]];</Font>
              flag:=true;             
          fi;   
      fi
     od;
   fi; 
od; </Font><Font italic="true" foreground="[153,51,255]">
end: </Font><Font bold="true" style="Text" executable="true" italic="true"># Deduce_ObjRela21</Font><Font italic="true" foreground="[153,51,255]">

Deduce_ObjRela22:=proc()</Font><Font italic="true" foreground="[255,51,51]">
local f,vars,vars1,vars2,fact,fact1,fact2,expr,news,ex,k,t;

for f in ObjStructTemp[7] do     
  if member([d,f],TestOCR) then next;fi;   
  vars:=`minus`(f[3],FK2);
  if nops(vars)=3 then 
    for fact in combinat[choose](FK45 minus DF53 minus DF43 ,2) do      
      fact1:=fact[1];
      fact2:=fact[2];
      vars1:=`minus`(Set_Vars(fact1),FK2);
      vars2:=`minus`(Set_Vars(fact2),FK2);
      if Unify_In1(vars1,vars) and nops(vars1)&gt;1 and Unify_In1(vars2,vars) and nops(vars2)&gt;1 then

         expr:=subs(FK3,{f[6],fact1,fact2});
         news:={};       
         if nops(expr)=3 then news:=MySolve(expr,vars,1);fi;       
         if news&lt;&gt;{}then 
             TestOCR:= TestOCR union {[d,f]};         
             for ex in news[1] do             
               k :=  Kind_Fact(ex);
               if  k&gt;=1 and k&lt;=11 and evalb(ex)= false and not Unify_In1(ex,FactSet) then

                  Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex];
                  FactSet:=FactSet union {ex};
               fi;
             od;
             t:=   f[3] union Set_Vars(fact1) union Set_Vars(fact2) minus vars;              
            <Font opaque="true" background="[204,204,204]"> Sol:=[op(Sol),[&quot;Deduce_ObjRela22&quot;,f,fact union {seq(t[i]=Get_Values(t[i]), i = 1..nops(t))},news[1]]];</Font>
             flag:=true;             
         fi;   
      fi;
    od;
   fi;
od;</Font><Font italic="true" foreground="[153,51,255]">
end: </Font><Font bold="true" style="Text" executable="true" italic="true"># Deduce_ObjRela22</Font><Font italic="true" foreground="[153,51,255]">
</Font><Font underline="true" foreground="[153,51,255]">
</Font><Font italic="true" foreground="[153,51,255]">Deduce_ObjRela3:=proc()</Font><Font italic="true" foreground="[255,51,51]">
local f,vars,expr,expr1,news,ex,k,fact;

for f in ObjStructTemp[7] do 
  if member([d,f],TestOCR) then next;fi;      
  expr:=subs(FK3,f[6]);
  for fact in FK45 minus DF53 minus DF43  do 
       news:={};  
       if f[2] = 1 and 
                   (`minus`(Set_Vars(fact),f[3])={} or
                   `minus`(f[3],Set_Vars(fact))={} ) then 

            vars:={`intersect`(Set_Vars(fact),f[3])[1]};             
            expr1:=MySolve(expr,vars,1);      
              if expr1={} then next;fi;
            news:={subs(expr1[1],fact)};           
print(news);

       elif f[2] = 0 and 
                   `minus`(f[5],Set_Vars(fact))={}and
                  (`minus`(Set_Vars(fact),f[3])={} or
                   `minus`(f[3],Set_Vars(fact))={} ) then 
          
           expr1:=MySolve(expr,f[5],1);
           if expr1={} then next;fi;
           news:={subs(expr1[1],fact)};
      fi:
      if news&lt;&gt;{}then 
           TestOCR:= TestOCR union {[d,f]};         
           for ex in news do             
             k :=  Kind_Fact(ex);
             if  k&gt;=1 and k&lt;=11 and 
                 not Unify_In1(ex,FactSet) then              
              Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex];
              FactSet:=FactSet union {ex};               
              flag:=true;             
             fi;
           od;
           <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_ObjRela3&quot;,[f,fact],{},news]];</Font>
                fi;           
  od;
od;</Font><Font italic="true" foreground="[153,51,255]">
end:  </Font><Font bold="true" style="Text" executable="true" italic="true"># Deduce_ObjRela3</Font><Font italic="true" foreground="[153,51,255]">
</Font><Font underline="true" foreground="[153,51,255]">
<Font bold="false">Deduce_ObjFunc:=proc()

end:</Font></Font><Font underline="true" foreground="[153,102,255]">

<Font bold="false">Deduce_ObjRules:=proc()</Font></Font><Font bold="false" underline="true" foreground="[255,51,51]">
local rule,news,ex,k,t,trihp,hamphu;

hamphu:=proc()
   local h,tt,doi,j;
   global DF3;
   tt:=op(0,rhs(rule[5]));
   doi:=[op(rhs(rule[5]))];
   for j to nops(doi) do
     if Unify_In1(doi[j],[op(Fact_Kinds[2]),op(Fact_Kinds[7])]) then doi[j]:=Get_Values(doi[j]);fi;od;
     h:= parse(cat(convert(lhs(rule[5]),string), &quot;=(&quot;,convert(tt(op(doi)),string),&quot;)&quot;));
     k := Kind_Fact(h);
     if  k=3 and not Unify_In1(h,FN)then     	
     	Fact_Kinds[k] :=[op(Fact_Kinds[k]),h];
        Fact_Kinds[2]:=[op(Fact_Kinds[2]),lhs(h)];
        DF3:=DF3 union {h};
     	FactSet:=FactSet union {h,lhs(h)};     	
     fi;
     return {h,lhs(h)};</Font><Font bold="false" underline="true" foreground="[153,51,255]">
end: </Font><Font bold="true" style="Text" underline="true" italic="true">
</Font><Font bold="true" style="Text" underline="true">
</Font><Font bold="true" style="Text"># Deduce_ObjRules'body</Font><Font foreground="[255,51,51]">
for rule in ObjStructTemp[8] do      
    if member([d,rule],TestOR) then next;fi;         
    news:=ApplyRule(rule,FactSet);
    if news&lt;&gt;{}then
       TestOR:=TestOR union {[d,rule]};       
       for ex in news do             
                k :=  Kind_Fact(ex);
                if  k&gt;=1 and k&lt;=11 and not Unify_In1(ex,FactSet) then
                  Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex];
                  FactSet:=FactSet union {ex};
                fi;
       od;
       trihp:={};   
       if(rule[5]&lt;&gt;&quot;&quot;) then 
          trihp:=hamphu();	
       fi;
       for t in {op(Fact_Kinds[3]), op(Fact_Kinds[8])} do
                if Unify_In1(lhs(t), rule[4][1]) then rule[4][1]:= Minus_Unify(rule[4][1] union {t}, {lhs(t)});fi;
       od:                                             	 
       <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_ObjRules&quot;,rule,rule[4][1],news union trihp]];</Font>
       flag:=true;                
     fi;      
od;</Font><Font foreground="[153,51,255]">
end:</Font><Font bold="true" style="Text"> </Font><Font foreground="[153,102,255]"> </Font><Font bold="true" style="Text" executable="true"># Deduce_ObjRules</Font><Font bold="true" style="Text">

#  Deduce_Object's body</Font><Font foreground="[255,51,51]">
  replace();
  </Font><Font bold="true" style="Text" executable="true" encoding="UTF-8"># - B\306\257\341\273\232C 1: </Font><Font bold="true" style="Text" encoding="UTF-8">D\303\262 t\303\254m c\303\241c t\303\255nh ch\341\272\245t b\303\252n trong c\341\272\245u tr\303\272c c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng </Font><Font bold="true" style="Text" executable="true">---</Font><Font foreground="[255,51,51]">
    if not member(d,TestProp) then
     Deduce_ObjProp();
    	 Deduce_From3s();
     	if flag and Test_Goal(Goal,FactSet) then return;fi;          
    fi;
    replace(); 
  </Font><Font bold="true" style="Text" executable="true" encoding="UTF-8"># - B\306\257\341\273\232C 2: Th\341\273\261c hi\341\273\207n t\303\255nh to\303\241n c\303\241c quan h\341\273\207 tr\303\252n c\341\272\245u tr\303\272c thi\341\272\277t l\341\272\255p ---</Font><Font foreground="[255,51,51]">
     	if not (type_Onet(d)= &quot;DOAN&quot; and not flagObj) then  		
	Deduce_OConstructRela();
   	   Deduce_From3s();
      if flag and Test_Goal(Goal,FactSet) then return;fi;
   	replace(); 
   	fi;
  </Font><Font bold="true" style="Text" executable="true" encoding="UTF-8"># - B\306\257\341\273\232C 3: D\303\262 t\303\254m lu\341\272\255t suy di\341\273\205n c\303\263 th\341\273\203 \303\241p d\341\273\245ng \304\221\306\260\341\273\243c b\303\252n trong c\341\272\245u tr\303\272c c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng ---</Font><Font foreground="[255,51,51]">
   Deduce_ObjRules();
   	Deduce_From3s();
   	if flag and Test_Goal(Goal,FactSet) then return;fi; 
 	replace();
 
  </Font><Font bold="true" style="Text">flag:=true;
  while flag do
  flag:=false;</Font><Font foreground="[255,51,51]">

  </Font><Font bold="true" style="Text" executable="true" encoding="UTF-8"># - B\306\257\341\273\232C 4: \303\201p d\341\273\245ng quy t\341\272\257c 1: \303\201p d\341\273\245ng 1 quan h\341\273\207 t\303\255nh to\303\241n f b\341\272\261ng c\303\241ch th\341\272\277 v\303\240o f c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 2, 3 \304\221\341\273\203 sinh ra c\303\241c s\341\273\261  ki\341\273\207n lo\341\272\241i 2, 3. \304\220i\341\273\201u ki\341\273\207n: f c\303\263 \304\221\303\272ng 1 bi\341\272\277n kh\303\264ng c\303\263 m\341\272\267t trong t\341\272\255p s\341\273\261 ki\341\273\207n lo\341\272\241i 2 ---</Font><Font foreground="[255,51,51]">
   Deduce_ObjRela1();
  	 Deduce_From3s();
   	if flag and Test_Goal(Goal,FactSet) then return;fi; 
  </Font><Font bold="true" style="Text" executable="true" encoding="UTF-8"># - B\306\257\341\273\232C 5: \303\201p d\341\273\245ng quy t\341\272\257c 2: \303\201p d\341\273\245ng nh\341\273\257ng quan h\341\273\207 t\303\255nh to\303\241n f ch\341\273\251a 2 bi\341\272\277n kh\303\264ng n\341\272\261m trong FactKinds[2] c\303\263 kh\341\272\243 n\304\203ng k\341\272\277t h\341\273\243p v\341\273\233i 1 s\341\273\261 ki\341\273\207n lo\341\272\241i 4, 5 c\303\271ng c\303\263 2 bi\341\272\277n nh\306\260 tr\303\252n \304\221\341\273\203 gi\341\272\243i ra s\341\273\261 ki\341\273\207n lo\341\272\241i 2, 3 m\341\273\233i ---</Font><Font foreground="[255,51,51]">
  Deduce_ObjRela21();
  	Deduce_From3s();
  	if flag and Test_Goal(Goal,FactSet) then return;fi;
        replace(); 
  </Font><Font bold="true" style="Text" executable="true" encoding="UTF-8"># - B\306\257\341\273\232C 6: Gi\341\273\221ng nh\306\260 b\306\260\341\273\233c 4: \303\201p d\341\273\245ng nh\341\273\257ng quan h\341\273\207 f ch\341\273\251a 3 bi\341\272\277n kh\303\264ng n\341\272\261m trong FactKinds[2] c\303\263 kh\341\272\243 n\304\203ng k\341\272\277t h\341\273\243p v\341\273\233i 2 s\341\273\261 ki\341\273\207n lo\341\272\241i 4, 5 c\303\271ng c\341\273\241 ---</Font><Font foreground="[255,51,51]">
  	Deduce_ObjRela22();
  	Deduce_From3s();
  	if flag and Test_Goal(Goal,FactSet) then return;fi; 
   	replace();
 # od;   </Font><Font foreground="[153,51,255]">
end proc:  </Font><Font bold="true" style="Text" executable="true">#  Deduce_Object</Font></Text-field>
</Input>
</Group>
<Group labelreference="L89">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#--------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L90">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_Objects]:=proc(Goal)</Font><Font bold="false">
local i, thutu;
thutu:=[];
 for i in Objects do 
       </Font>if type_Onet(i)= &quot;EDGE&quot; then thutu:=[i,op(thutu)];<Font bold="false">
       if type_Onet(i)=&quot;GRAPH&quot;</Font> <Font bold="false">then thutu:=[op(thutu),i];
      fi</Font>;  
od;<Font bold="false">
for i in thutu do
      Deduce_Object(i,Goal);
      if flag and Test_Goal(Goal,FactSet) then return;fi;      <Font foreground="[255,51,51]">od;
return [</Font>Fact_Kinds<Font foreground="[255,51,51]">,Sol]; </Font></Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Deduce_Objects</Font></Text-field>
</Input>
<Input>
<Text-field prompt="&gt; " style="Maple Input" alignment="left" firstindent="0" spacebelow="0" leftmargin="0" linespacing="0.0" initial="0" linebreak="space" rightmargin="0" bulletsuffix="" spaceabove="0" bullet="none" pagebreak-before="false"></Text-field>
</Input>
<Output>
<Text-field style="HyperlinkError" layout="HyperlinkError"><Hyperlink linktarget="http://www.maplesoft.com/support/help/errors/view.aspx?path=Error,%20reserved%20word%20%60od%60%20unexpected" hyperlink="true"><Font style="HyperlinkError">Error, reserved word `od` unexpected</Font></Hyperlink></Text-field>
</Output>
</Group>
<Group labelreference="L91">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L92">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_From53s]:=proc()</Font><Font style="Text">
<Font encoding="UTF-8"> # Sinh ra s\341\273\261 ki\341\273\207n m\341\273\233i lo\341\272\241i 3, 4, 5 t\341\273\253 1 s\341\273\261 ki\341\273\207n lo\341\272\241i 5 v\303\240 nhi\341\273\201u s\341\273\261 ki\341\273\207n lo\341\272\241i 3 b\341\272\261ng c\303\241ch th\341\272\277 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 3 v\303\240o s\341\273\261 ki\341\273\207n lo\341\272\241i 5</Font></Font><Font bold="false">
local fact5,fact3,news, vars5,f, k ;
global Fact_Kinds,FactSet,Sol,flag,DF53;

   for fact5 in Fact_Kinds[5] do
      if member(fact5,DF53) then next;fi; 
      news:=lhs(fact5)-rhs(fact5)=0; 
      vars5:= Set_Vars(fact5);
      for fact3 in Fact_Kinds[3] do
         for f in vars5 do
	     if Unify_Fact(lhs(fact3), f) then
                news:= subs(f = rhs(fact3),news);             
             fi;
         od;    
      od;
      if nops(Set_Vars(news))=1 then news:=MySolve(news,Set_Vars(news),1)[1][1]; fi;        
      if nops(Set_Vars(news)) &lt; nops(vars5)  then
               DF53:= DF53 union {fact5};
               <Font foreground="[255,51,51]">k :=  Kind_Fact(news);
               if  k&gt;=1 and k&lt;=11 and not Unify_In1(news,FactSet) then</Font>
                 Fact_Kinds[k]:= [op(Fact_Kinds[k]),news]; 
                 FactSet:= FactSet union {news}; 
                  <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_From53s&quot;,[],{fact5,fact3},{news}]];  </Font>                          flag:= true; 
               fi; 
      fi; 
   od;  </Font><Font foreground="[153,51,255]">
end proc: </Font><Font style="Text" executable="true"># Deduce_From5s3s</Font></Text-field>
</Input>
</Group>
<Group labelreference="L93">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#---------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L94">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_From43s]:=proc()</Font><Font style="Text">
<Font encoding="UTF-8"># Sinh ra c\303\241c s\341\273\261 ki\341\273\207n m\341\273\233i lo\341\272\241i 3 t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 3, 4 b\341\272\261ng c\303\241ch th\341\272\277 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 3 v\303\240o c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 4</Font></Font><Font bold="false">
local fact4,fact3,news,k;
global Fact_Kinds, DF43, flag, FactSet, Sol;</Font>
  
  <Font bold="false"> for fact4 in Fact_Kinds[4] do
      if member(fact4,DF43) then next;fi; 
         for fact3 in Fact_Kinds[3] do
            news:={};
	    if Unify_Fact(lhs(fact3), lhs(fact4)) then
               news:={subs(lhs(fact3) = rhs(fact4),fact3)};       
            elif Unify_Fact(lhs(fact3), rhs(fact4)) then
               news:={subs(lhs(fact3) = lhs(fact),fact3)};
            fi;
            if news &lt;&gt; {}  then
               DF43:= DF43 union {fact4};
               <Font foreground="[255,51,51]">k :=  Kind_Fact(news[1]);
               if  k&gt;=1 and k&lt;=11 and not Unify_In1(news[1],FactSet) then</Font>
                 Fact_Kinds[k]:= [op(Fact_Kinds[k]),op(news)]; 
                 FactSet:= FactSet union news; 
                 <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_From4s&quot;,[],{fact4,fact3},news]];</Font>                               flag:= true; 
            fi; 
            fi; 
         od; 
   od;</Font> <Font bold="false">
return [Fact_Kinds,Sol];</Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># Deduce_From43s</Font></Text-field>
</Input>
</Group>
<Group labelreference="L95">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#--------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L96">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Replace_DS] := proc(tends,kieuds)</Font><Font bold="false">
local temp, i, th,thi;
   temp := []; 
   for i in tends do temp := [op(temp),type_Onet(i)];od;
   if temp = kieuds then return tends;
   else       
      th :=  combinat[permute](tends,nops(tends));
      for thi in th do 
         temp :=[];
         if thi &lt;&gt; tends then
           for i in thi do temp := [op(temp),type_Onet(i)]; od;
           if temp = kieuds then return thi;fi  ; 
         fi;
      od; 
   fi; </Font><Font foreground="[153,102,255]">
end:  </Font><Font style="Text" executable="true"># Replace_DS</Font></Text-field>
</Input>
</Group>
<Group labelreference="L97">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#---------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L98">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_From9]:=proc(fact9)</Font><Font style="Text" encoding="UTF-8">  # Th\341\273\247 t\341\273\245c: x\341\273\255 l\303\275 1 s\341\273\261 ki\341\273\207n lo\341\272\241i 9 b\341\272\261ng c\303\241ch t\303\255nh to\303\241n h\303\240m
</Font><Font bold="false">local Values, i, func,k, funcstruct,facts,Set, gtbien,tam;
global Fact_Kinds,TestF,Sol;
    Values:= Get_Values([op(rhs(fact9))]);
    func:=<Font foreground="[255,51,51]">type_Onet(</Font>rhs(fact9)<Font foreground="[255,51,51]">);</Font>
    if not member([func,[op(rhs(fact9))]],TestF) then
       funcstruct:=Find_FuncStruct(func);      
       facts:= Compute_Func(funcstruct,Replace_DS([op(rhs(fact9))],func[3]),Values,lhs(fact9));
       TestF:=TestF union {[func,[op(rhs(fact9))]]};
       Set:=Classify_Facts([op(facts)]);
       gtbien := {}; 
       for i in [op(rhs(fact9))] do
           if type_Onet(i)=&quot;DUONGTHANG&quot; or type_Onet(i)=&quot;DOAN&quot; then 
               tam:= parse(cat(convert(i,string),&quot;.f&quot;));
               gtbien := gtbien union {tam=Get_Values(i)};
           else  gtbien := gtbien union {i = Get_Values(i)};
           fi;
       od;
       <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_From9&quot;,[func],{fact9} union gtbien,Set]];    </Font>      
    fi;</Font><Font foreground="[153,51,255]">    
end proc: </Font><Font style="Text" executable="true">#  Deduce_From9</Font></Text-field>
</Input>
</Group>
<Group labelreference="L99">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L100">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_From9s]:=proc()</Font><Font style="Text" encoding="UTF-8"> # Th\341\273\247 t\341\273\245c: X\341\273\255 l\303\275 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 9 b\341\272\261ng c\303\241ch t\303\255nh to\303\241n h\303\240m
</Font><Font bold="false">local fact9;
global Fact_Kinds, DF9; 
   for fact9 in Fact_Kinds[9] do
        if not member(fact9,DF9) and SubList([op(rhs(fact9))], Fact_Kinds[2]) then
	    Deduce_From9(fact9);
            DF9:= DF9 union {fact9};
        fi;
   od; 
return <Font foreground="[255,51,51]">[</Font>Fact_Kinds<Font foreground="[255,51,51]">,Sol]</Font> ;</Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true">#  Deduce_From9s</Font></Text-field>
</Input>
</Group>
<Group labelreference="L101">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#----------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L102">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font><Font foreground="[153,0,255]">Deduce_From983s]:=proc()</Font>
<Font style="Text" encoding="UTF-8"># Th\341\273\247 t\341\273\245c: Sinh ra c\303\241c s\341\273\261 ki\341\273\207n m\341\273\233i t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 3, 8, 9 b\341\272\261ng c\303\241ch th\341\272\277 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 3, 8 v\303\240o s\341\273\261 ki\341\273\207n lo\341\272\241i 9</Font><Font bold="false">
local fact9, temp, fact3,fact8;
global Fact_Kinds, flag, FactSet, Sol, DF9; 

   for fact9 in Fact_Kinds[9] do 
      if not member(fact9,DF9) then
         for fact3 in Fact_Kinds[3] do
             if Unify_Fact(lhs(fact9), lhs(fact3)) and not Unify_Fact(rhs(fact9),Fact_Kinds[8])then 
                temp:= subs(lhs(fact3) = rhs(fact9), fact3);
                Fact_Kinds[8]:= [op(Fact_Kinds[8]),temp]; 
                FactSet:= FactSet union {temp}; 
                <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;deduce 983&quot;,[],{fact9,fact3},{temp}]];</Font>
                DF9:= DF9 union {fact9} ;
                flag:= true; 
                break;
             fi; 
         od; 
         if not member(fact9,DF9) then
            for fact8 in Fact_Kinds[8] do
               if Unify_Fact(rhs(fact9), lhs(fact8)) and not Unify_Fact(lhs(fact9),Fact_Kinds[3]) then 
                  temp:= subs(lhs(fact8) = lhs(fact9), fact8);
                  Fact_Kinds[3]:= [op(Fact_Kinds[3]),temp];
                  FactSet:= FactSet union {temp}; 
                  <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;deduce 983&quot;,[],{fact9,fact8},{temp}]];</Font>
                  DF9:= DF9 union {fact9} ;
                  flag:= true;
                  break; 
               fi; 
            od;     
         fi;      
      fi;
   od; 
 return [Fact_Kinds,Sol]; </Font><Font foreground="[153,0,255]">
end: </Font><Font style="Text" executable="true"># Deduce_From983s</Font><Font bold="false">       </Font></Text-field>
</Input>
</Group>
<Group labelreference="L103">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L104">
<Input>
<Text-field prompt="&gt; " style="Maple Input" italic="true" layout="Normal"><Font italic="true" foreground="[153,51,255]">GRAPH_THEORY[Deduce_Funcs]:=proc(Goal)</Font><Font italic="true">
   </Font><Font bold="true" style="Text" encoding="UTF-8"># Sinh ra c\303\241c s\341\273\261 ki\341\273\207n m\341\273\233i, \304\221\341\273\221i t\306\260\341\273\243ng m\341\273\233i b\341\272\261ng c\303\241ch \303\241p d\341\273\245ng t\303\255nh to\303\241n tr\303\252n h\303\240m \304\221\341\273\203 gi\341\272\243i</Font><Font italic="true">
local HuongMT, 
     func, uutien, kh_uutien, GoalType, ds, ToHop, funcstruct,temp,FactTypes,
     FuncsApp, FuncStruct, FuncNew, i, tri,Values,facts,k,Set, HMT, co,gtbien, tam;
global Found, Objects, Obj_Types, TestF, FactsNew,Funcs,Sol;
      
     HuongMT:= proc(MT)</Font><Font bold="true" style="Text" executable="true"> </Font><Font bold="true" style="Text" encoding="UTF-8"># Th\341\273\247 t\341\273\245c con: tr\341\272\243 v\341\273\201 nh\341\273\257ng ki\341\273\203u \304\221\341\273\221i t\306\260\341\273\243ng h\306\260\341\273\233ng m\341\273\245c ti\303\252u</Font><Font bold="true" style="Text" executable="true">
</Font><Font italic="true">        if evalb(MT = &quot;GRAPH&quot;) then return [&quot;GRAPH&quot;,set];
        elif evalb(MT = set) then return [set];
        elif evalb(MT = &quot;EDGE&quot;) then return [&quot;EDGE&quot;,set];
        else return [];
        fi;  
     end:

 </Font><Font bold="true" style="Text" executable="true"> </Font><Font bold="true" style="Text"># Deduce_Funcs's body<Font executable="true">    
     </Font><Font encoding="UTF-8"># T\303\254m ki\341\272\277m c\303\241c h\303\240m h\306\260\341\273\233ng m\341\273\245c ti\303\252u v\303\240 c\303\263 \304\221\341\273\221i s\341\273\221 x\303\241c \304\221\341\273\213nh</Font><Font executable="true">
</Font></Font><Font italic="true">     HMT := HuongMT(type_Onet(Goal,1)); 
      FactTypes:=Find_Fact_Types([op(Fact_Kinds[2])],1); 
     FuncsApp:=[];
     for func in Fun_Names do
        if member(func[1],HMT) and SubList(func[3],FactTypes) then 
           FuncsApp:= [op(FuncsApp),func];
        fi;
     od;

    </Font><Font bold="true" style="Text" executable="true"> </Font><Font bold="true" style="Text" encoding="UTF-8"># Th\341\273\261c hi\341\273\207n t\303\255nh to\303\241n tr\303\252n t\341\273\253ng h\303\240m</Font><Font bold="true" style="Text" executable="true"> </Font><Font italic="true">     	
     FuncNew:={};gtbien:={};
     for func in FuncsApp do
         funcstruct:=Find_FuncStruct(func);
         if func[4]={&quot;doi xung&quot;} then
            ToHop:= MyCombinat(func[3], Fact_Kinds[2],1);     
         else  
            ToHop:= MyCombinat(func[3], Fact_Kinds[2]);
         fi;
         for ds to nops(ToHop) do
             if member([func,ToHop[ds]],TestF) then next;fi;
             Values:=Get_Values(ToHop[ds]); 
             
             FuncNew:= Compute_Func(funcstruct,ToHop[ds],Values);
             if FuncNew &lt;&gt; {} then
 		Set:=Classify_Facts(convert(FuncNew,list));
                for i in <Font opaque="true" background="[204,204,204]">ToHop[ds]</Font> do
                   if type_Onet(i)=&quot;DUONGTHANG&quot; or type_Onet(i)=&quot;DOAN&quot; then 
                       tam:= parse(cat(convert(i,string),&quot;.f&quot;));
               		gtbien := gtbien union {tam=Get_Values(i)};
                   else  gtbien := gtbien union {i = Get_Values(i)};
                   fi;
                od;
                <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_Funcs&quot;,[func],gtbien,Set]]; </Font><Font foreground="[255,51,51]">
                </Font>TestF:=TestF union {[func,ToHop[ds]]} ;<Font foreground="[255,51,51]"> 
	    fi;</Font>
    </Font><Font bold="true" style="Text">            </Font><Font italic="true">od;
     od;<Font foreground="[255,51,51]">
return [</Font>Fact_Kinds<Font foreground="[255,51,51]">,Sol];</Font><Font foreground="[153,51,255]">
end proc: </Font></Font><Font bold="true" style="Text" executable="true"># Deduce_Funcs</Font></Text-field>
</Input>
</Group>
<Group labelreference="L105">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L106">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Find_OdinaryFunc] := proc(func)</Font><Font bold="false">
local fn;
   for fn in Fun_Names do
      if convert(op(0,func),string)=fn[2] and nops([op(func)])=nops(fn[3]) and SubList([op(func)],fn[3]) then
         if fn[4]= {&quot;doi xung&quot;} then 
            return [fn[1],fn[2],fn[3]];    
         else return [fn[1],convert(op(0,func),string),[op(func)]];
         fi;      
      fi;   
   od;   </Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># Find_OdinaryFunc</Font></Text-field>
</Input>
</Group>
<Group labelreference="L107">
<Input>
<Text-field prompt="&gt; " style="Maple Input" bold="false" layout="Normal"><Font bold="false">#-------------------------------------------
GRAPH_THEORY[Belong_In] := proc(fact, Facts)</Font><Font style="Text" executable="true" encoding="UTF-8">  # Th\341\273\247 t\341\273\245c t\303\254m fact c\303\263 trong t\341\272\255p Facts hay kh\303\264ng?</Font><Font bold="false">
local f;
    for f to nops(Facts) do
        if Facts[f]=fact then return f;fi;
    od; 
    return -1;
end:</Font></Text-field>
</Input>
</Group>
<Group labelreference="L108">
<Input>
<Text-field prompt="&gt; " style="Maple Input" bold="false" layout="Normal"><Font bold="false">#-----------------------------------</Font></Text-field>
</Input>
</Group>
<Group labelreference="L109">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Odinary_Hypos_Rules]:= proc() </Font><Font style="Text" executable="true"># <Font encoding="UTF-8">Th\341\273\247 t\341\273\245c l\341\272\245y d\341\272\241ng g\341\273\221c c\341\273\247a gi\341\272\243 thi\341\272\277t c\341\273\247a c\303\241c lu\341\272\255t</Font></Font><Font bold="false">
local  Odinary_Hypos_Rule, tenham, Rule;
global O_Hypos_Rules; 
    
    Odinary_Hypos_Rule :=  proc(rule)  
    local fact, o_fact, f, thaythe, lhs_fact, o_number,vitri;
    
       o_fact := [];o_number:=[];
       thaythe := {seq(rule[2][i] = rule[3][i],i=1..nops(rule[2]))};

       for fact in rule[4][1] do
          # su kien loai 6
          if type(fact,`list`) and type(fact[1],`string`) then
             fact := subs(thaythe,fact);
             for f to nops(fact) do
                if type(fact[f],`indexed`) then
                    fact := subs(fact[f] = NameType(fact[f]),fact); 
                elif type(fact[f],`function`) and op(0,fact[f])&lt;&gt;`.` then
                    fact :=  subs(fact[f] = convert(op(0,fact[f]),string),fact); 
                fi;
             od; 	        
             fact := Is_RelationType(fact,1);
             vitri := Belong_In(fact,o_fact);
             if vitri = -1 then
                o_fact:= [op(o_fact),fact];o_number :=[op(o_number),1]; 
	     else   o_number[vitri]:= o_number[vitri]+1; fi; 

         # su kien loai 1
         # su kien loai 9
         elif type(fact,`=`) and member(convert(op(0,rhs(fact)),string),tenham) and 
             not member(convert(op(0,lhs(fact)),string),tenham)  then
                fact := subs(thaythe,fact); lhs_fact:= lhs(fact); 
                fact := Find_OdinaryFunc(rhs(fact));
                fact := lhs_fact=fact;
                vitri := Belong_In(fact,o_fact);
        	if vitri = -1 then
             	  o_fact:= [op(o_fact),fact];o_number :=[op(o_number),1]; 
        	else   o_number[vitri]:= o_number[vitri]+1; fi;  
        fi;
        
    od; 
    return [o_fact,o_number];
   end: # Odinary_Hypos_Rule 
    </Font><Font style="Text">

# Odinary_Hypos_Rules's body</Font><Font foreground="[153,51,255]">
   if O_Hypos_Rules = [] then 
      </Font><Font bold="false">tenham := [seq(Fun_Names[i][2],i=1..nops(Fun_Names))];</Font><Font foreground="[153,51,255]"> 
      </Font><Font foreground="[255,0,51]">for Rule in Rule_Structs do
         O_Hypos_Rules := [op(O_Hypos_Rules),Odinary_Hypos_Rule(Rule)];
      od;</Font><Font foreground="[153,51,255]">
   fi;
end:  </Font><Font style="Text" executable="true"># Odinary_Hypos_Rules</Font></Text-field>
</Input>
</Group>
<Group labelreference="L110">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-----------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L111">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Odinary_Hypos]:= proc() </Font><Font style="Text" executable="true" encoding="UTF-8"># T\303\254m l\341\272\241i d\341\272\241ng g\341\273\221c c\341\273\247a s\341\273\261 ki\341\273\207n</Font><Font bold="false">
local o_fact, thaythe, f, fact, tam, vt, vp, o_number,vitri;
global Fact_Kinds, Objects, Obj_Types;

     o_fact := [];o_number:=[];
    for fact in Fact_Kinds[9] do
	vt := type_Onet(lhs(fact)); tam := type_Onet(rhs(fact));vp:=[tam[1],tam[2],tam[3]];
        vt := vt=vp;   
        vitri := Belong_In(vt,o_fact);
        if vitri = -1 then
               o_fact:= [op(o_fact),vt];o_number :=[op(o_number),1]; 
        else   o_number[vitri]:= o_number[vitri]+1; fi; 
    od;     </Font>

    <Font bold="false">for fact in Fact_Kinds[6] do
       for f to nops(fact) do 
          if not type(fact[f],`string`) then 
            fact[f]:= subs(fact[f]=type_Onet(fact[f],1),fact[f]);
          fi;
       od;   
       fact := Is_RelationType(fact,1);
        vitri := Belong_In(fact,o_fact);
        if vitri = -1 then
               o_fact:= [op(o_fact),fact];o_number :=[op(o_number),1]; 
        else   o_number[vitri]:= o_number[vitri]+1; fi; 
    od; 

    return [o_fact,o_number];</Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># GRAPH_THEORY[Odinary_Hypos]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L112">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#----------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L113">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Classify_Rules]:= proc(s)</Font><Font bold="false">
local r, Rules_Temp, fact6, i, Fact_Hypos, o_hypos, o_rules,vitri, cothoa;
global Rule_Structs, Obj_Types, Fact_Kinds, O_Hypos_Rules;
 
   Odinary_Hypos_Rules(); 
   o_hypos := Odinary_Hypos();  Rules_Temp := []; fact6:= {};

   #for i in Fact_Kinds[6] do
   #   if i[1]=&quot;GRAPH&quot; then fact6:=fact6 union {&quot;GRAPH&quot;};break;fi;
   #od;

   for r to nops(Rule_Structs) do
      if member(Rule_Structs[r][1],[op(s),op(fact6)]) and SubList(Rule_Structs[r][3],Obj_Types) then
         o_rules := O_Hypos_Rules[r];
         cothoa := true;
         for i to nops(o_rules[1]) do
              vitri := Belong_In(o_rules[1][i],o_hypos[1]);
              if vitri = -1 then cothoa := false;break;
              else 
                  if o_rules[2][i] &gt; o_hypos[2][vitri] then cothoa:=false;break;fi;
              fi;
         od;         
        
         if cothoa then 
              if Rule_Structs[r][1] = &quot;GRAPH&quot; or Rule_Structs[r][1] = &quot;logic&quot; then 
                Rules_Temp := [Rule_Structs[r], op(Rules_Temp)];
             else Rules_Temp := [op(Rules_Temp),Rule_Structs[r]];fi;
         fi;    
             
      fi;
   od;
   return Rules_Temp;</Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># GRAPH_THEORY[Classify_Rules]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L114">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#---------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L115">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Deduce_Rules]:=proc()</Font><Font style="Text">
<Font encoding="UTF-8"># Th\341\273\247 t\341\273\245c: D\303\262 t\303\254m c\303\241c lu\341\272\255t c\303\263 th\341\273\203 \303\241p d\341\273\245ng \304\221\306\260\341\273\243c [&quot;&quot;,[dt],[kieudt],[{gt},{kl}]]</Font></Font><Font bold="false" foreground="[255,51,51]">
local i,j, Cb,Comb,ReRule,news,ex,k,trihp,hamphu, CombTemp, ct, temp, loaiToHop, TimDoiTuongNen, Rules_Temp, t;
global FactSet,Fact_Kinds,flag,Sol,TestR,Obj_Types,Objects,OAttrs,OAttr_Types;</Font><Font bold="false" foreground="[153,51,255]">

hamphu:=proc()</Font>
   <Font bold="false">local h,tt,doi,j;</Font>
   <Font bold="false">global DF3;</Font>
   <Font bold="false" foreground="[255,51,51]">tt:=op(0,rhs(ReRule[5]));
   doi:=[op(rhs(ReRule[5]))];
   for j to nops(doi) do
     if Unify_In1(doi[j],[op(Fact_Kinds[2]),op(Fact_Kinds[7])]) then doi[j]:=Get_Values(doi[j]);fi;od;
     h:= parse(cat(convert(lhs(ReRule[5]),string), &quot;=(&quot;,convert(tt(op(doi)),string),&quot;)&quot;));
     k := Kind_Fact(h);
     if  k=3 and not Unify_In1(h,FN)then     	
     	Fact_Kinds[k] :=[op(Fact_Kinds[k]),h];
        Fact_Kinds[2]:=[op(Fact_Kinds[2]),lhs(h)];
        DF3:=DF3 union {h};
     	FactSet:=FactSet union {h,lhs(h)};     	
     fi;</Font><Font bold="false" foreground="[153,51,255]">
     return </Font><Font bold="false" foreground="[255,51,51]">{h,lhs(h)}</Font><Font bold="false" foreground="[153,51,255]">;
end: </Font><Font style="Text" executable="true"># hamphu</Font><Font bold="false" foreground="[153,51,255]">

TimDoiTuongNen := proc(tendtmoi, tendtcu, varscu)</Font><Font bold="false">
local fact1; 
   if tendtmoi &lt;&gt; tendtcu then
      for  fact1 in Fact_Kinds[1] do
         if fact1[1]=tendtmoi then
            return {op(parse(fact1[2]))};
         fi;
      od;
   else return varscu;fi;<Font foreground="[153,0,255]">
end:  </Font></Font><Font style="Text" executable="true"># TimDoiTuongNen</Font><Font bold="false" foreground="[153,51,255]">

loaiToHop := proc(doiso, tohop) </Font>
  <Font bold="false"> local  n, tohoptam, vars, dothi, th, co, ds;
   n := -1;
   #for ds to nops(doiso) do 
    #  if  doiso[ds] = &quot;GRAPH&quot; then n := ds;break;fi;
   #od;
   if n &lt;&gt; -1 then
      tohoptam := [];vars :={};co:='chuaco';
      for th in tohop do
         vars := TimDoiTuongNen(th[n],co, vars);
         co := th[n]; 
         if vars =   {th[1],th[2],th[3]} then tohoptam := [op(tohoptam),th];fi;
      od;
      return tohoptam;
   else return tohop;
   fi;  <Font foreground="[153,51,255]">
end:  </Font></Font><Font style="Text" executable="true"># loaiToHop</Font>
#trace(loaiToHop) ;#trace(TimDoiTuongNen);<Font style="Text">
  <Font encoding="UTF-8"># B1: T\303\254m c\303\241c lu\341\272\255t c\303\263 th\341\273\203 \303\241p d\341\273\245ng \304\221\306\260\341\273\243c</Font></Font><Font bold="false">
Rules_Temp := Classify_Rules(Obj_Types);</Font><Font style="Text">
</Font><Font bold="false" foreground="[255,51,51]">for i in Rules_Temp do </Font><Font style="Text" encoding="UTF-8"># D\303\262 t\341\273\253ng lu\341\272\255t 1</Font><Font bold="false" foreground="[255,51,51]">    
 </Font><Font style="Text" encoding="UTF-8"># B2: T\341\273\225 h\341\273\243p c\303\241c \304\221\341\273\221it t\306\260\341\273\243ng trong b\303\240i to\303\241n c\303\263 th\341\273\203 \303\241p d\341\273\245ng tr\303\252n lu\341\272\255t</Font><Font bold="false" foreground="[255,51,51]">
	Comb:=MyCombinat(i[3],[op(Objects),op(OAttrs)]);        
        Comb := loaiToHop(i[3],Comb);
        for Cb in Comb do          
           if member([Cb,i],TestR) then next;fi;           
 </Font><Font style="Text" encoding="UTF-8"># B3: X\303\251t t\341\273\253ng t\341\273\225 h\341\273\243p 1 v\303\240 th\341\272\277 c\303\241c ph\341\272\247n t\341\273\255 trong t\341\273\253ng t\341\273\225 h\341\273\243p v\303\240o lu\341\272\255t</Font><Font bold="false" foreground="[255,51,51]">
	   ReRule:=ReplaceR(Cb,i);
 </Font><Font style="Text" encoding="UTF-8"># B4: Ki\341\273\203m tra t\341\273\225 h\341\273\243p n\303\240y c\303\263 \303\241p d\341\273\245ng \304\221\306\260\341\273\243c kh\303\264ng? N\341\272\277u c\303\263 th\303\254 l\306\260u s\341\273\261 ki\341\273\207n m\341\273\233i \304\221\306\260\341\273\243c sinh ra v\303\240o news</Font><Font bold="false" foreground="[255,51,51]">
           news:=ApplyRule(ReRule,FactSet);
 </Font><Font style="Text" encoding="UTF-8"># B5: Ki\341\273\203m tra c\303\241c s\341\273\261 ki\341\273\207n m\341\273\233i sinh ra, n\341\272\277u kh\303\264ng thu\341\273\231c t\341\272\255p s\341\273\261 ki\341\273\207n m\341\273\233i FN th\303\254 th\303\252m v\303\240o FN v\303\240 c\341\272\255p nh\341\272\245t b\306\260\341\273\233c gi\341\272\243i</Font><Font bold="false" foreground="[255,51,51]">
            if news&lt;&gt;{}then
             TestR:= TestR union {[Cb,i]};   
            for ex in news do             
              </Font>	<Font bold="false">if type(ex, list) then 
		   for j in ex do
			if ValidStructName_Onet(j) and Unify_In1({op(j)},Objects) and not Unify_In1(j, Objects) then
                		if type_Onet(j) = &quot;type?&quot; then next;fi;
                		Obj_Types:=[op(Obj_Types),type_Onet(j)];
                		Objects:=[op(Objects),j]; 
    			elif type(j,function) and op(0,j)=`.` and 
         					Unify_In1(op(1,j),Objects)then
                		if type_Onet(j) = &quot;type?&quot; then next;fi;                       
                		OAttrs := [op(OAttrs), j] ;
                		OAttr_Types := [op(OAttr_Types), type_Onet(j)];
			fi; 
		    od;							   
		fi;<Font foreground="[255,51,51]">
		k :=  Kind_Fact(ex);
                if  k&gt;=1 and k&lt;=11 and not Unify_In1(ex,FactSet) then
                  Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex];
                  FactSet:=FactSet union {ex};
                fi;       
             od;
 </Font></Font><Font style="Text" encoding="UTF-8"># B6: N\341\272\277u lu\341\272\255t c\303\263 k\303\250m theo th\341\273\247 t\341\273\245c ph\341\273\245 \304\221\341\273\203 t\303\255nh gi\303\241 tr\341\273\213 c\341\273\247a s\341\273\261 ki\341\273\207n m\341\273\233i th\303\254 g\341\273\215i c\303\241c th\341\273\247 t\341\273\245c n\303\240y.
     VD: Vi\341\272\277t ph\306\260\306\241ng tr\303\254nh \304\221\306\260\341\273\235ng th\341\272\263ng</Font><Font bold="false" foreground="[255,51,51]">
                trihp:={};
        	if(ReRule[5]&lt;&gt;&quot;&quot;) then 
	            trihp:=hamphu();	
             	fi;</Font><Font style="Text"> 
                             </Font><Font bold="false">#------------<Font foreground="[255,51,51]"> 
             for t in {op(Fact_Kinds[3]), op(Fact_Kinds[8])} do
                if Unify_In1(lhs(t), ReRule[4][1]) then ReRule[4][1]:= Minus_Unify(ReRule[4][1] union {t}, {lhs(t)});fi;
             od:           
             <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Deduce_Rules&quot;,i,ReRule[4][1],news union trihp ]];</Font>
             flag:=true;              </Font></Font><Font style="Text">
 	         </Font><Font bold="false" foreground="[255,51,51]">fi; 
        od;     
 od; 
return [</Font><Font bold="false">Fact_Kinds<Font foreground="[255,51,51]">,Sol];       </Font></Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Deduce_Rules</Font></Text-field>
</Input>
</Group>
<Group labelreference="L116">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L117">
<Input>
<Text-field style="Text" layout="Normal"><Font style="Maple Input" opaque="true" background="[255,255,153]" foreground="[102,102,255]">GRAPH_THEORY[Deduce_EqsGoal] := proc(Goal)</Font><Font bold="false" style="Maple Input">
local goal, typegoal, k, Value,v,VarsTemp,
       Vars,ans,Values,RuleFunc,co,
      find_rule, test_values, find_fact8, rule_func, find_fact10,<Font foreground="[153,102,255]">find_fact9,</Font>find_fact3_object, Has_Equal, DongNhat_Pt,find_fact11;
global RuleEqs_Structs, Objects, FactSet, Fact_Kinds,flag, Sol;

   Has_Equal := proc(eq, Eqs)
   local ee, e, eco, EqsTemp;
      EqsTemp := Eqs;
      for ee in eq do
         eco := false;  
         for e in Eqs do
           if Is_Equal(e,ee) then eco := true;break;fi;
         od;      
         if not eco then  EqsTemp := EqsTemp  union {ee};fi;
      od;
      return EqsTemp;   
   end: 
 
  <Font foreground="[153,102,255]">test_values := proc(tohops, giatris)</Font>
   local j, giatristemp;
         giatristemp := giatris;  
         if type(giatris,`set`) then giatristemp:=giatris[1];fi;
         if nops(giatristemp) = 1 then return true;fi;
         if nargs = 3 then 
             if member(&quot;cxd&quot;,giatristemp) and {op(giatristemp)} &lt;&gt; {&quot;cxd&quot;} then
		 return true;fi;  
         elif member(&quot;cxd&quot;,giatristemp) then
		 return true;fi;
         return false;
   <Font foreground="[153,102,255]">end: </Font></Font><Font executable="true"># test_values</Font><Font bold="false" style="Maple Input">
   
  </Font><Font style="Maple Input"> <Font bold="false">find_rule := proc()
   local rule, combs, cb, rerule, tam, c, giathiet;
      tam:= [];
      for rule in RuleEqs_Structs do
         combs := MyCombinat(rule[3],Objects,1);
         for  cb in combs do
            if test_values(cb,Get_Values(cb)) then 
                rerule := ReplaceR(cb,rule);
                if {op(rerule[3])}={&quot;DOAN&quot;}  then
                    giathiet := rerule[4][1][1];
                    if member(giathiet[2],[op(giathiet[3])]) and 
                       ({op(Get_Values([giathiet[2],giathiet[3]]))}={&quot;cxd&quot;} or
                       {op(Get_Values([giathiet[2],giathiet[3]]))}={&quot;xd&quot;,&quot;cxd&quot;} or
			{op(Get_Values([giathiet[2],giathiet[3]]))}={&quot;xd&quot;} ) 
                       then next; fi;
                fi;
                if Unify_In1(rerule[4][1], FactSet) then
                    if not member(&quot;EDGE&quot;, rerule[3]) then tam:= [rerule,op(tam)];
                    else tam:= [op(tam),rerule];fi;
                    for c in cb do
                       if not evalb(type_Onet(c)=&quot;GRAPH&quot;) then Vars := Union_Unify(Vars,{c});fi;
                    od;            
                fi; 
            fi; 
         od;      
      od;
      RuleFunc := [op(RuleFunc),op(tam)];co := [op(co),seq(&quot;rule&quot;, i=1..nops(tam))];  
   end : </Font></Font><Font executable="true"># find_rule</Font><Font bold="false" style="Maple Input">
   
   <Font foreground="[153,102,255]">find_fact8 := proc()</Font>
   local fact8;
      for fact8 in Fact_Kinds[8] do
         if test_values([op(lhs(fact8))],Get_Values([op(lhs(fact8))])) then
            RuleFunc := [op(RuleFunc),fact8];   co := [op(co),&quot;fact8&quot;];
            Vars := Union_Unify(Vars,{op(lhs(fact8))});
         fi; 
      od;
   <Font foreground="[153,102,255]">end: </Font></Font><Font executable="true">#find_fact8</Font><Font bold="false" style="Maple Input">

  <Font foreground="[153,102,255]">find_fact9 := proc()</Font>
  </Font><Font style="Maple Input"> <Font bold="false">local fact9;
     for fact9 in Fact_Kinds[9] do
      if test_values([lhs(fact9),op(rhs(fact9))],Get_Values([lhs(fact9),op(rhs(fact9))])) then
             RuleFunc := [op(RuleFunc),fact9];co := [op(co),&quot;fact9&quot;]; 
             Vars := Union_Unify(Vars,{lhs(fact9),op(rhs(fact9))});
       fi;
     od; 
   <Font foreground="[153,51,255]">end: </Font></Font></Font><Font executable="true"># find_fact9</Font><Font bold="false" style="Maple Input">

   <Font foreground="[153,102,255]">find_fact10 := proc()</Font>
   local fact10;
       for fact10 in Fact_Kinds[10] do
          if  nops({op(lhs(fact10))})&lt;&gt; 1 and test_values([op(lhs(fact10)),op(rhs(fact10))],Get_Values([op(lhs(fact10)),op(rhs(fact10))])) then
             RuleFunc := [op(RuleFunc),fact10];co := [op(co),&quot;fact10&quot;]; 
             Vars := Union_Unify(Vars,{op(lhs(fact10)),op(rhs(fact10))});
          fi;
       od; 
   <Font foreground="[153,51,255]">end: </Font></Font><Font executable="true"># find_fact10</Font><Font bold="false" style="Maple Input">

   find_fact11 := proc()
   local fact11, vars_fact11, v, vars_func;
       for fact11 in Fact_Kinds[11] do
           vars_fact11 := Set_Vars(fact11); vars_func := {};
           for v in vars_fact11 do
             vars_func := vars_func union {op(v)};   
          od;  
           if test_values([op(vars_func)],Get_Values([op(vars_func)])) then
              RuleFunc := [op(RuleFunc),fact11];co:=[op(co),&quot;fact11&quot;];
              Vars := Union_Unify(Vars, vars_func);   
           fi;     
       od;     
   end: </Font><Font executable="true"># find_fact11</Font><Font bold="false" style="Maple Input">

   <Font foreground="[153,102,255]">find_fact3_object := proc()</Font>
   local fact3, construct, obj, att, c, vars,j, varstem;
      for fact3 in Fact_Kinds[3] do
         if member(lhs(fact3),OAttrs) then 
            construct := ObjStruct_Replace(op(lhs(fact3))[1])[5];
            if construct &lt;&gt; [] then
               for c in construct do
                   if Unify_Fact(lhs(c),lhs(fact3)) then
                      vars := Set_Vars(rhs(c));
                      for j in vars do
                      if type(j,function)and op(0,j) &lt;&gt; `.` then 
                          vars:= vars minus {j} union Set_Vars(op(j));fi;
                      od;
                       varstem:={};
                      for j in vars do
                         if type(j,function)and op(0,j)= `.`  then
                            varstem := varstem union {op(j)[1]};
                         else  varstem := varstem union {j};fi; 
                      od;   
                      Sol := [op(Sol),[&quot;find_fact3_object&quot;,{},{fact3,c},{rhs(c) = rhs(fact3)}]];  

                      RuleFunc:= [op(RuleFunc),[rhs(c) = rhs(fact3),[op(varstem),lhs(fact3)],vars]];
                      co := [op(co),&quot;fact3_object&quot;];
                      Vars := Union_Unify(Vars,{op(varstem),lhs(fact3)});
                   fi;   
               od;  
            fi; 
         fi;
      od; 
   end : </Font><Font executable="true"># find_fact3_object</Font><Font bold="false" style="Maple Input">  
 
   DongNhat_Pt := proc(pt1,pt2)
   local sh11,sh21,sh31,sh12,sh22,sh32;
      sh11 := coeff(lhs(pt1),x);
      sh21 := coeff(lhs(pt1),y);
      sh31 := lhs(pt1)-(sh11*x+sh21*y);

      sh12 := coeff(lhs(pt2),x);
      sh22 := coeff(lhs(pt2),y);
      sh32 := lhs(pt2)-(sh12*x+sh22*y);           

      return {sh11=sh12,sh21=sh22,sh31=sh32};
   end: </Font><Font executable="true"># DongNhat_Pt</Font><Font bold="false" style="Maple Input">
  
   <Font foreground="[153,102,255]">rule_func := proc(giatri, goal)</Font>
   local funcname, giatritemp,eq2,Eqs,Eq,rf,vt,vp,eq,j,ex,exgt,thaythe,ngt,goaltemp,v,gtbien,
         test_solve,GetVars_Poly,get_values,solve_eqs, init_values,<Font foreground="[0,102,102]">get_value,</Font>find_eqs, test_vars;

      <Font foreground="[0,102,102]">get_value := proc(bien,tapbien,tapgt)
      local b,gt;
         gt := Get_Values(bien);
         if gt = &quot;cxd&quot; or gt = &quot;xd&quot; then
           for b to nops(tapbien) do
              if Unify_Fact(tapbien[b],bien) then return tapgt[b];fi
           od;  
         fi;    </Font>
         return gt;   <Font foreground="[0,102,102]">
      end: </Font></Font><Font executable="true"># get_value</Font><Font bold="false" style="Maple Input" foreground="[0,102,102]">    </Font><Font bold="false" style="Maple Input"> 

      <Font foreground="[0,102,102]">get_values := proc(biens,tapbien,tapgt)</Font>
      local b, gts;
          gts := [];
          for b in biens do gts := [op(gts),get_value(b,tapbien,tapgt)];od; 
          return gts;  
      <Font foreground="[0,102,102]">end: </Font></Font><Font executable="true"># get_values
</Font><Font bold="false" style="Maple Input">
     </Font>   <Font bold="false" style="Maple Input" foreground="[0,102,102]">init_values := proc(biens,giatris)</Font><Font bold="false" style="Maple Input">
      local b , giatristemp, init_value, temp,funcname,vt,h, gt, tam, bienstemp;

             init_value := proc(bien)
              local b1, b2, gtb1, gtb2, btemp, ds, ds_values;                 
                  if type_Onet(bien) = &quot;EDGE&quot; then return [bien[1],bien[2]];
                  elif evalb(type_Onet(bien) = &quot;DUONGTHANG&quot;) or 
                     (evalb(type_Onet(bien) = &quot;EDGE&quot;) and not type(bien,`indexed`)) then
                      tam:= tam union {bien[1]=1};
                      return bien[1]*x + bien[2]*y + bien[3]=0;
                  elif evalb(type_Onet(bien) = &quot;EDGE&quot;) and type(bien,`indexed`) then
                      b1:= op(bien); b2:= b1[2];b1:=b1[1];
                      gtb1:= get_value(b1,bienstemp,giatristemp);
                      gtb2 := get_value(b2,bienstemp,giatristemp);
                      if gtb1=&quot;cxd&quot; or gtb1=&quot;xd&quot; then gtb1:=init_value(b1);fi;
                      if gtb2=&quot;cxd&quot; or gtb2=&quot;xd&quot; then gtb2:=init_value(b2);fi; 
                        
                      tam:= tam union {gtb2[2]-gtb1[2]=1};
                      if not type(gtb1[1],`indexed`) or not type(gtb1[2],`indexed`) then
                          btemp := gtb1;
                      else btemp:= gtb2 ;
                      fi; 
                      return (gtb2[1]-gtb1[1])*(x-btemp[1])+(gtb2[2]-gtb1[2])*(y-btemp[2])=0;
		  fi;   
             end: </Font><Font executable="true"># init_value</Font><Font bold="false" style="Maple Input">
        
         #trace(init_value);
         tam:={};
         giatristemp:= giatris; bienstemp := biens;
         for b to nops(biens) do
            gt := get_value(biens[b],biens,giatristemp); 
            if gt = &quot;cxd&quot; or gt = &quot;xd&quot; then
                if Is_Function(biens[b]) then
                
                   temp:= init_values([op(biens[b])],get_values([op(biens[b])],biens, giatristemp));
                   funcname:= Find_FuncStruct(type_Onet(biens[b]));
	           funcname:= parse(funcname[4]);

                 
      	           vt:=funcname(op(temp[1]));
                   giatristemp[b] := vt;
                else      
                   giatristemp[b] := init_value(biens[b]);fi;
            fi;
         od; 
         return [giatristemp, tam]; 
      <Font foreground="[0,153,153]">end: </Font></Font><Font executable="true"># init_values</Font><Font bold="false" style="Maple Input" foreground="[0,153,153]">  </Font>

             <Font bold="false" style="Maple Input" foreground="[0,153,153]">GetVars_Poly:=proc(expr)</Font><Font bold="false" style="Maple Input">
      local F,i;
         if  type(expr, constant) or type(expr, string) then return({});
         elif type(expr,`name`)or type(expr,`indexed`) or 
           (type(expr, function) and evalb(op(0,expr) = &quot;.&quot; ))then return {expr};
         elif type(expr,`set`) or type(expr,list)then
            F:={}; 
            for i in expr do F:= F union GetVars_Poly(i);od; 
            return F;   
         else F:= GetVars_Poly({op(expr)}); return F;fi;
       <Font foreground="[0,102,102]">end :  </Font></Font><Font executable="true">#  GetVars_Poly</Font><Font bold="false" style="Maple Input" foreground="[0,102,102]"> </Font>
 
             <Font bold="false" style="Maple Input" foreground="[0,102,102]">test_solve := proc(pts)</Font><Font bold="false" style="Maple Input">
         ans := GetVars_Poly(pts);
         if nops(pts) &lt; nops(ans) then return false;fi;
         return true;
      <Font foreground="[0,102,102]">end: </Font></Font><Font executable="true"># test_solve</Font><Font bold="false" style="Maple Input" foreground="[0,102,102]"> </Font>
              <Font bold="false" style="Maple Input">
      <Font foreground="[0,153,153]">test_vars:= proc(e, pts)</Font>
      local tam1, tam2, var1, var2, jj, tam;
        var1 := GetVars_Poly(e); var2 := GetVars_Poly(pts);
        if var1 intersect var2 &lt;&gt; {} then return true;fi;
        tam1:= {};
        for  jj in var1 do
           tam := convert(jj, string);
           if length(tam) &gt;= 3 then tam1:= tam1 union {parse(substring(tam,1..length(tam)-3))};
           else tam1:= tam1 union {jj};fi;
        od; 
        tam2:= {};
        for  jj in var2 do
           tam := convert(jj, string);
           if length(tam) &gt;= 3 then tam2:= tam2 union {parse(substring(tam,1..length(tam)-3))};
           else tam2:= tam2 union {jj};  fi;              
        od; 
        if tam1 intersect tam2 &lt;&gt; {} then return  true;fi;
        return false;
      <Font foreground="[0,102,102]">end: </Font></Font><Font executable="true"># test_vars</Font><Font bold="false" style="Maple Input" foreground="[0,102,102]"> </Font><Font bold="false" style="Maple Input">

      <Font foreground="[0,153,153]">find_eqs:= proc(eqs)</Font>
      local e, tappt, t,r,ee, tappt_temp;
         #trace(test_solve);
         tappt := [];  tappt_temp := [];
         for e in eqs do  
                
            if test_solve({e}) and {e}&lt;&gt; Eq then tappt_temp := [op(tappt_temp),{e}];next;fi; 
            if tappt &lt;&gt; [] then
              r:= false; 
              for t to nops(tappt) do
                if test_vars(e,tappt[t]) then 
                  tappt[t]:= tappt[t] union {e};r:= true;fi; 
              od;
              if not r then tappt := [op(tappt),{e}];    fi;
            else tappt := [op(tappt),{e}]; fi; 
         od;  
       
         for e from 1 to nops(tappt) do
            if nops(tappt) = 1 then return [op(tappt_temp),op(tappt)];fi;
              for ee from e + 1 to nops(tappt) do 
                if ee &lt;= nops(tappt) then
                if tappt[ee] intersect tappt[e] &lt;&gt; {} then 
                  tappt[e]:= tappt[e] union tappt[ee]; 
                  tappt := [seq(tappt[i],i=1..ee-1), seq(tappt[i],i=ee+1..nops(tappt))];  
                  ee := ee-1; 
                  if nops(tappt) = 1 then return [op(tappt_temp),op(tappt)];fi; 
                fi; fi;
              od;
         od;
      
      return [op(tappt_temp),op(tappt)]; 
     <Font foreground="[0,102,102]">end:  </Font></Font><Font executable="true"># find_eqs
</Font><Font bold="false" style="Maple Input">
    </Font><Font style="Maple Input"> </Font><Font bold="true"> </Font><Font bold="false" style="Maple Input" foreground="[0,153,153]">solve_eqs:= proc(goaltemp)</Font><Font bold="false" style="Maple Input">
      local nghiem, n, tam, t, ta, thu, thutam, roi,ni, EqsTemp, ita, kq;
         #trace(find_eqs);
         if Eqs = {} then return;fi;
         for ita in Eqs do
             if lhs(ita)=rhs(ita) then Eqs := Eqs minus {ita};fi;
         od;     
         tam := find_eqs(Eqs); ngt :=0;
         for  ta in tam do
            if ta = {} then next;fi;
            if test_solve(ta) then 
               nghiem:= MySolve(ta,ans);
               if nghiem = {} then next;fi; 
               kq:={}; 
 	       for n in  nghiem do
                   for ni in n do 
                     if not type(rhs(ni),`integer`) and not type(rhs(ni),`fraction`) and  not type(rhs(ni),`float`) and not type(rhs(ni),`^`) and not type(rhs(ni),`*`) then
                     n := n  minus {ni}     ;fi;
                  od;    
		  if n &lt;&gt; {} then 	 
                   thutam := subs(n, giatritemp);
                   for t to nops(Vars) do
                       if (GetVars_Poly(thutam[t]) minus {x,y}) = {} then
                           if type_Onet(Vars[t])= &quot;DUONGTHANG&quot; or  type_Onet(Vars[t])=&quot;DOAN&quot; then
                                thu := Vars[t].f = thutam[t];
                           else thu := Vars[t] = thutam[t]; fi;
                           if not Unify_In1(thu, Fact_Kinds[3]) then
                             Fact_Kinds[3]:=[op(Fact_Kinds[3]),thu];
			     FactSet:= FactSet union {thu};
                             flag:=true;
                             kq:= kq union  <Font background="[255,255,255]"> {thu};</Font>                             
                           fi;  
                       fi; 
                   od;
                 fi; 
                od; 
                <Font opaque="true" background="[204,204,204]">Sol :=[op(Sol),[[&quot;Deduce_EqsGoal&quot;],[],ta,kq]]; </Font> 
                if nops(nghiem) &gt; 1 then  ngt := 1; return;fi;
                giatritemp := thutam;
                Eqs:= subs(n,Eqs);
                for ita in Eqs do
                   if lhs(ita)=rhs(ita) then Eqs := Eqs minus {ita};fi;
                od;  
            fi; 
         od:
      end: </Font><Font executable="true"># solve_eqs</Font><Font bold="false" style="Maple Input"> </Font><Font style="Maple Input">    <Font bold="false">
   </Font></Font>
        # rule_func's body<Font bold="false" style="Maple Input">      
 </Font><Font style="Maple Input">  #<Font bold="false">trace(solve_eqs);
   # trace(init_values);

   giatritemp := init_values(Vars,giatri);Eq:= giatritemp[2];giatritemp := giatritemp[1]; 
      Eqs := {}; 
      goaltemp := goal;     
     for rf to nops(RuleFunc) do
      
          if evalb(co[rf]=&quot;rule&quot;) then 
            eq2 := {};
            if RuleFunc[rf][4][2] &lt;&gt; {} then eq := RuleFunc[rf][4][2];
            else 
               funcname := op(0,RuleFunc[rf][5]);
               gtbien:=   get_values(RuleFunc[rf][2],Vars,giatritemp);
               eq:= {funcname(op(gtbien))};    
               gtbien:= {seq(RuleFunc[rf][2][j]=gtbien[j],j=1..nops(gtbien))};
            fi;
            if member(x,GetVars_Poly(eq)) or member(y, GetVars_Poly(eq)) then
                 ex:= convert((op(GetVars_Poly(eq)minus{x,y})),string);
                 ex := parse(substring(ex, 1..length(ex)-3));
                 for j to nops(Vars) do
                    if Vars[j]=ex then giatritemp[j]:= op(eq);eq2:= {ex = (op(eq))};fi;
                 od;  
            fi;
           </Font> <Font bold="false">if eq2 = {} then Eqs := Has_Equal(eq,Eqs);
               <Font opaque="true" background="[204,204,204]">Sol := [op(Sol),[&quot;Thiet lap phuong trinh tu luat&quot;,RuleFunc[rf],RuleFunc[rf][4][1] union gtbien,eq]];</Font>             
            else 
               <Font opaque="true" background="[204,204,204]">Sol := [op(Sol),[&quot;Thiet lap phuong trinh tu luat&quot;,RuleFunc[rf],RuleFunc[rf][4][1] union gtbien,eq2]];</Font>            
            fi;

         elif  evalb(co[rf]=&quot;fact8&quot;) then
            funcname:= Find_FuncStruct(type_Onet(lhs(RuleFunc[rf])));
	    funcname:= parse(funcname[4]);
            gtbien := get_values([op(lhs(RuleFunc[rf]))],Vars,giatritemp);
            vt:=funcname(op(gtbien));
            gtbien := {seq([op(lhs(RuleFunc[rf]))][j]=gtbien[j],j=1..nops(gtbien)) };   
            vp := rhs(RuleFunc[rf]);
            if type(vt,`list`) and type(vp,`list`) and nops(vt) = nops(vp) then
               eq:={}; 
               for  j to nops(vt) do
                  eq := eq union {vt[j] = vp[j] };
               od; 
            elif type(vt,`=`) then eq := DongNhat_Pt(vt,vp);   
            else eq := {vt=vp};  
            fi; 
            <Font opaque="true" background="[204,204,204]">Sol := [op(Sol),[&quot;Thanh lap phuong trinh tu sk8&quot;,[],{RuleFunc[rf]} union gtbien,eq]];</Font>
            Eqs := Has_Equal(eq,Eqs);


         elif evalb(co[rf] = &quot;fact9&quot;) then
	    vt:= get_value(lhs(RuleFunc[rf]),Vars,giatritemp);
            funcname:= Find_FuncStruct(type_Onet(rhs(RuleFunc[rf])));
            funcname:= parse(funcname[4]);
            gtbien:= get_values([op(rhs(RuleFunc[rf]))],Vars,giatritemp);
	    vp:=funcname(op(gtbien));
            gtbien:= {seq([op(rhs(RuleFunc[rf]))][j]=gtbien[j],j=1..nops(gtbien))} union {lhs(RuleFunc[rf])=vt}; 
            if type(vt,`list`) and type(vp,`list`) and nops(vp) = nops(vt) then
              eq:= {};
              for  j to nops(vt) do
                  eq := eq union {vt[j] = vp[j] };
               od; 
            elif type(vt,`=`) then eq := DongNhat_Pt(vt,vp);   
            else eq := {vt=vp};                   
            fi;
           <Font opaque="true" background="[204,204,204]"> Sol := [op(Sol),[&quot;Thanh lap phuong trinh tu sk9&quot;,[],{RuleFunc[rf]} union gtbien,eq]];</Font> </Font></Font> <Font bold="false" style="Maple Input">  
            Eqs := Has_Equal(eq,Eqs);


         elif evalb(co[rf] = &quot;fact10&quot;) then
            funcname:= Find_FuncStruct(type_Onet(lhs(RuleFunc[rf])));
            funcname:= parse(funcname[4]); 
	    vt:=funcname(op(get_values([op(lhs(RuleFunc[rf]))],Vars,giatritemp)));
            funcname:= Find_FuncStruct(type_Onet(rhs(RuleFunc[rf])));
            funcname:= parse(funcname[4]); 
            vp:=funcname(op(get_values([op(rhs(RuleFunc[rf]))],Vars,giatritemp)));
            if type(vt,`list`) and type(vp,`list`) and nops(vp)= nops(vt) then
              eq:= {};
              for  j to nops(vt) do
                  eq := eq union {vt[j] = vp[j] };
               od;   
            elif type(vt,`=`) then eq := DongNhat_Pt(vt,vp);   
            else eq := {vt=vp};         
            fi;
            vt:= {op(lhs(RuleFunc[rf])),op(rhs(RuleFunc[rf]))}; vt := [op(vt)];
            gtbien := get_values(vt,Vars,giatritemp);
            gtbien := {seq(vt[j]=gtbien[j],j=1..nops(gtbien))}; 
           <Font opaque="true" background="[204,204,204]"> Sol := [op(Sol),[&quot;Thanh lap phuong trinh tu sk10&quot;,[],{RuleFunc[rf]} union gtbien,eq]];</Font>
            Eqs := Has_Equal(eq,Eqs);
          

          elif evalb(co[rf]=&quot;fact11&quot;) then
               vt := [op(Set_Vars(RuleFunc[rf]))]; vp := [] ; gtbien:= {};               
               for v in vt do
                  funcname:= Find_FuncStruct(type_Onet(v));
            	  funcname:= parse(funcname[4]); 
	    	  vp:= [op(vp),funcname(op(get_values([op(v)],Vars,giatritemp)))];
                  gtbien := gtbien union {op(v)};
               od;
               vt := {seq(vt[i]=vp[i],i=1..nops(vt))};
               vt := subs(vt, RuleFunc[rf]); vp := rhs(vt); vt := lhs(vt);
               if type(vt,`list`) and type(vp,`list`) and nops(vt)=nops(vp) then
                  eq:= {};
                  for  j to nops(vt) do
                     eq := eq union {vt[j] = vp[j] };
                  od;  
	       elif type(vt,`=`) then eq := DongNhat_Pt(vt,vp);   
               else eq := {vt=vp};         
               fi;
               vt:= [op(gtbien)]; 
               gtbien := get_values(vt,Vars,giatritemp); 
               gtbien := {seq(vt[j]=gtbien[j],j=1..nops(gtbien))}; 
               </Font><Font style="Maple Input" opaque="true" background="[204,204,204]">Sol := [op(Sol),[&quot;Thanh lap phuong trinh tu sk11&quot;,[],{RuleFunc[rf]} union gtbien,eq]];</Font><Font bold="false" style="Maple Input">
               Eqs := Has_Equal(eq,Eqs);


          elif  evalb(co[rf] = &quot;fact3_object&quot;) then
           ex := RuleFunc[rf][1]; thaythe:={}; 
           for j in RuleFunc[rf][3] do 
               if type(j,`function`) and op(0,j)=`.` then
                  exgt:= get_value(op(j)[1],Vars,giatritemp);
                  if op(j)[2] = x then thaythe:=thaythe union {j=exgt[1]};
                  elif op(j)[2] = y then thaythe:=thaythe union {j=exgt[2]};
                  fi;
              else thaythe := thaythe union {j=get_value(j,Vars, giatritemp)}; 
              fi;  
           od; 
           
           eq := {subs(thaythe,RuleFunc[rf][1])};
          <Font opaque="true" background="[204,204,204]"> Sol := [op(Sol),[&quot; Thanh lap phuong trinh tu sk3&quot;,[],{RuleFunc[rf][1],op(thaythe)},eq]]; </Font>
           Eqs := Has_Equal(eq,Eqs);
         fi;
        
              
         if nops(Eqs) = 2  then
            ex := (map(s-&gt;parse(substring(convert(s,string),1..length(convert(s,string))-3)),GetVars_Poly(Eqs))) ; 
          
            if nops(ex) = 1 and (type_Onet(ex[1])=&quot;DUONGTHANG&quot; or type_Onet(ex[1])=&quot;DOAN&quot; ) then
               Eqs := Has_Equal(Eq,Eqs);fi;
         fi;  
         
         solve_eqs(goaltemp);
         if Test_Goal(goaltemp,FactSet) and nops(Goals) = 1 then return;fi;   
         if rf =  nops(RuleFunc) then Eqs := Has_Equal(Eq,Eqs);solve_eqs(goaltemp);fi;  
         if ngt =1 then return;fi;         

      od;
   <Font foreground="[153,102,255]">end: </Font></Font><Font executable="true"># rule_func</Font>

 # Deduce_EqsGoal's body<Font bold="false" style="Maple Input">
   goal := Goal; typegoal := type_Onet(goal);
   if evalb(typegoal = &quot;PTDT_TQ&quot;) then goal:= op(goal)[1];typegoal:=&quot;DUONGTHANG&quot;;fi;
   RuleFunc := []; co := []; Vars := {};
   
   #trace(find_rule); trace(find_fact8);trace(find_fact9);trace(find_fact10);
   #trace(find_fact3_object);
   #trace(rule_func);
   </Font><Font encoding="UTF-8"># T\303\254m lu\341\272\255t, h\303\240m sinh ph\306\260\306\241ng tr\303\254nh</Font><Font bold="false" style="Maple Input">
   print(&quot;bat dau tim kiem&quot;);  
   find_rule();
   find_fact8();
   find_fact10();
   find_fact11();
   find_fact9();
   find_fact3_object();
   print(&quot;-----&quot;, RuleFunc); 
   </Font><Font encoding="UTF-8"># Th\341\273\255 gi\341\272\243i ph\306\260\306\241ng tr\303\254nh v\341\273\233i tr\306\260\341\273\235ng h\341\273\243p c\303\263 nhi\341\273\201u nghi\341\273\207m</Font><Font bold="false" style="Maple Input">
   </Font><Font executable="true" encoding="UTF-8"># S\341\272\257p x\341\272\277p c\303\241c bi\341\272\277n</Font><Font bold="false" style="Maple Input">
     VarsTemp := [];
     for  v in Vars do
        if type(v,`indexed`) or type(v,`function`) then
              VarsTemp := [op(VarsTemp),v];
        else VarsTemp := [v,op(VarsTemp)];
        fi; 
     od;  
     Vars := VarsTemp;
    </Font><Font executable="true" encoding="UTF-8"># K\341\272\277t th\303\272c s\341\272\257p x\341\272\277p c\303\241c bi\341\272\277n</Font><Font bold="false" style="Maple Input"> 
   Values := Get_Values(Vars);k:= Unify_In(goal,Vars);
   if type(Values,`set`) then
      for Value in Values do rule_func(Value,goal);if not flag then break;fi;od;
   else
    # print(&quot;tttt&quot;);
    # trace(rule_func); 
     rule_func(Values,goal);
   fi;  
 #  return [Fact_Kinds,Sol];</Font><Font style="Maple Input" foreground="[102,51,255]">
end: </Font><Font executable="true"># Deduce_EqsGoal
</Font></Text-field>
</Input>
</Group>
<Section collapsed="false" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title>
<Text-field style="Heading 3" layout="Heading 3"></Text-field></Title>
<Group labelreference="L118">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#--------------------<Font style="Text">
<Font encoding="UTF-8"># C\303\201C TH\341\273\246 T\341\273\244C PH\341\273\244</Font></Font></Text-field>
</Input>
</Group>
<Group labelreference="L119">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font>ptdtss]<Font bold="false">:=proc(M,a)
return a[2]*(x-M[1])-a[1]*(y-M[2])=0;</Font>
end:</Text-field>
</Input>
</Group>
<Group labelreference="L120">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font>ptdtvg]<Font bold="false">:=proc(M,n)
return n[1]*(x-M[1])+n[2]*(y-M[2])=0;</Font>
end:</Text-field>
</Input>
</Group>
<Group labelreference="L121">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font><Font foreground="[255,51,51]">ptdt2d]<Font bold="false">:=proc(A,B)
return (x-A[1])*(B[2]-A[2])-(B[1]-A[1])*(y-A[2])=0;</Font>
end:</Font></Text-field>
</Input>
</Group>
<Group labelreference="L122">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font>ptdthsg]<Font bold="false">:=proc(k,A)
return k*x-y-k*A[1]+A[2]=0;</Font>
end:</Text-field>
</Input>
</Group>
<Group labelreference="L123">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font>ptdssdt]:=proc(M,d)<Font bold="false">
return coeff(lhs(d),x)*(x-M[1])+coeff(lhs(d),y)*(y-M[2])=0;</Font>
end:</Text-field>
</Input>
</Group>
<Group labelreference="L124">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font>ptdvgdt]:=proc(M,d)<Font bold="false">
return -coeff(lhs(d),y)*(x-M[1])+coeff(lhs(d),x)*(y-M[2])=0;</Font>
end:</Text-field>
</Input>
</Group>
<Group labelreference="L125">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font>tlpt]:= proc(M,d)<Font bold="false">
return subs({x = M[1],y = M[2]},d);</Font>
end:  <Font style="Text" executable="true"># GRAPH_THEORY[tlpt]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L126">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font>tlptdssd]:= proc(d1,d2)<Font bold="false"> 
local a1,b1,a2,b2;
a1:= coeff(lhs(d1),x);a2:= coeff(lhs(d2),x);b1:= coeff(lhs(d1),y);b2:= coeff(lhs(d2),y);
if type(a1,`name`) and type(b1,`name`) then return subs({a1=a2,b1=b2},d1);fi; 
if type(a2,`name`) and type(b2,`name`) then return subs({a2=a1,b2=b1},d2);fi; </Font>
end: <Font style="Text" executable="true"># GRAPH_THEORY[tlptdssd]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L127">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font>tlptdvgd]:= proc(d1,d2)<Font bold="false"> 
local a1,b1,a2,b2;
a1:= coeff(lhs(d1),x);a2:= coeff(lhs(d2),x);b1:= coeff(lhs(d1),y);b2:= coeff(lhs(d2),y);
if type(a1,`name`) and type(b1,`name`) then return subs({a1=b2,b1=-a2},d1);fi; 
if type(a2,`name`) and type(b2,`name`) then return subs({a2=b1,b2=-a1},d2);fi; </Font>
end: <Font style="Text" executable="true"># GRAPH_THEORY[tlptdvgd]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L128">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,102,255]">GRAPH_THEORY[tvh]:=proc(A,B,C)</Font>
   return (A[1]-C[1])*(B[1]-C[1]) + (A[2]-C[2])*(B[2]-C[2]) =0;<Font foreground="[153,102,255]">
end: </Font><Font style="Text" executable="true"># GRAPH_THEORY[tvh]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L161" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">GRAPH_THEORY[addV]:=proc(V,v)
   V := V union {v};
   return V;
end:</Text-field>
</Input>
</Group>
<Group labelreference="L129">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#------------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L130">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text" executable="true" encoding="UTF-8"># C\303\241c th\341\273\247 t\341\273\245c ph\341\273\245c v\341\273\245 cho vi\341\273\207c xu\341\272\245t ra m\303\240n h\303\254nh</Font></Text-field>
</Input>
</Group>
<Group labelreference="L131">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[get_Object</Font>]:= proc()<Font bold="false"> </Font>
local O, i;
global Objects, Obj_Types;
O := [];
for i to nops(Objects) do
   O := [op(O),cat(convert(Objects[i],string),&quot;:&quot;,Obj_Types[i])];
od; 
return O;
end: <Font style="Text" executable="true"># GRAPH_THEORY[get_Object]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L132">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[get_Param</Font>]:= proc()<Font bold="false"> </Font>
global Params;
return [op(Params)];
end: <Font style="Text" executable="true"># GRAPH_THEORY[get_Param]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L133">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[get_Hypos</Font>]:= proc()<Font bold="false"> </Font>
global Facts, Functions;
return [op(Facts),op(Functions)];
end: <Font style="Text" executable="true"># GRAPH_THEORY[get_Hypos]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L134">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[get_Goal</Font>]:= proc()<Font bold="false"> </Font>
global Goals;
return Goals;
end: <Font style="Text" executable="true"># GRAPH_THEORY[get_Goal]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L135">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" background="[255,204,0]" foreground="[153,51,255]">GRAPH_THEORY[get_Solution]:= proc()<Font bold="false"> </Font></Font><Font bold="false">
local S,SN, value, Goal,STemp, g,
      Solution, show_Goal;
global Sol, FactSet, Goals;</Font><Font style="Text">       

<Font encoding="UTF-8">    # B\341\272\257t \304\221\341\272\247u c\303\241c th\341\273\247 t\341\273\245c ph\341\273\245</Font></Font>
   <Font bold="false" foreground="[0,153,51]">Solution:=proc(Goal)</Font><Font bold="false">
   local goalvars,Solnew,Step,i;
     goalvars:={Goal};
     Solnew:=[];
     for i from nops(Sol) to 1 by -1 do 
       Step:=Sol[i];      
       if member(Step,STemp) then break;fi;   
       if  Intersect_Unify(Step[4],goalvars) &lt;&gt; {} or `intersect`(Step[4],goalvars)&lt;&gt;{} then         
         Step[4] := Intersect_Unify(Step[4],goalvars) union `intersect`(Step[4],goalvars);        
         if Step[1] &lt;&gt; &quot;Deduce_From3s&quot; and Step[1] &lt;&gt; &quot;Deduce_From8s&quot; then          
         	Solnew := [Step, op(Solnew)];fi;
         goalvars := Union_Unify(Minus_Unify(goalvars,Step[4]),Step[3]);
       fi; 
     od;
     return(Solnew);
     <Font foreground="[0,153,51]">end: </Font></Font><Font style="Text" executable="true"># Solution</Font><Font bold="false">

     <Font foreground="[0,153,51]">show_Goal := proc(Goal)</Font>
     local t1, t2, t3, i;  
       if not Test_Goal(Goal, FactSet) then 
<Font encoding="UTF-8">         S := [op(S), cat(&quot;*** R\341\272\245t ti\341\272\277c &quot;, convert(Goal,string),&quot;  kh\303\264ng gi\341\272\243i \304\221\306\260\341\273\243c.&quot;)];
</Font>       else 
         SN := Solution(Goal); STemp := [op(STemp),op(SN)];
         value := Get_Values(Goal);
         S:= [op(S),&quot;</Font>***<Font encoding="UTF-8" size="14">K\341\272\276T QU\341\272\242 C\341\272\246N T\303\214M L\303\200:</Font><Font bold="false"> &quot;];
         if type(value,`set`) then
           for i in value do
             S := [op(S), cat(&quot;          &quot;,convert(Goal,string) , &quot;=&quot;, convert(i,string))]; 
           od;
         else<Font family="Times New Roman"> </Font>
           S := [op(S), cat(&quot;          &quot;,convert(Goal,string) , &quot;=&quot;, convert(value,string))]; 
         fi;
<Font encoding="UTF-8">         S := [op(S), &quot;\134n</Font></Font>*****<Font bold="false"> </Font><Font encoding="UTF-8" size="14">C\303\201C B\306\257\341\273\232C TH\341\273\260C HI\341\273\206N NH\306\257 SAU:</Font><Font bold="false"> </Font>*****<Font bold="false">&quot;];
         for i to nops(SN) do
           S := [op(S), cat(&quot;<Font family="Times New Roman" encoding="UTF-8"> \134n </Font></Font><Font family="Times New Roman">*<Font underline="true" encoding="UTF-8" size="14">B\306\260\341\273\233c</Font><Font bold="false"> </Font></Font><Font bold="false">&quot;, <Font size="14">i</Font>,&quot;</Font><Font size="14">:</Font>* &quot;)];
<Font bold="false">           t1 := cat(&quot;      Suy ra:   &quot; , convert(SN[i][4],string)); 
<Font encoding="UTF-8">           t2 := cat(&quot;      T\341\273\253</Font><Font family="Times New Roman"> :      </Font>&quot;, convert(SN[i][3],string)); 
           if SN[i][2] &lt;&gt; [] then 
<Font encoding="UTF-8">             t3 := cat(&quot;          V\303\254 :   &quot;,convert(SN[i][2],string)); 
</Font>   	     S:= [op(S), t2,t1,t3];
           else S:= [op(S),t2,t1];fi;
         od; 
       fi;</Font>
     <Font bold="false" foreground="[0,153,51]">end: </Font><Font style="Text" executable="true"># show_Goal 
   </Font><Font style="Text" encoding="UTF-8"># K\341\272\277t th\303\272c c\303\241c th\341\273\247 t\341\273\245c ph\341\273\245</Font><Font style="Text">
<Font size="14">
# get_Solution's body</Font></Font><Font bold="false">
  S := [];STemp := [];
  for g to nops(Goals) do     
<Font encoding="UTF-8">     S:= [op(S), cat(&quot;\134n\134n *** </Font></Font><Font family="Times New Roman" encoding="UTF-8">C\303\202U</Font><Font bold="false" family="Times New Roman">   &quot; </Font><Font bold="false">, convert(g,string), &quot; : &quot;, &quot;  </Font><Font encoding="UTF-8">T\303\214M</Font><Font bold="false"> &quot;, convert(Goals[g],string))]; 
     show_Goal(Goals[g]);     
  od;
return S;</Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># GRAPH_THEORY[get_Solution]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L136">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[xuly_Object] := proc(SObject)</Font><Font bold="false">
local i, k, ten, kieu, n;
global Objects, Obj_Types;
for i in SObject do
   k := SearchText(&quot;:&quot;, i);
   if(k&gt;0) then
     ten := [parse( substring(i,1..(k-1)))]; n := nops(ten);
     kieu := convert(parse(substring(i, k+1..length(i))),string);
     Objects := [op(Objects),op(ten)];
     Obj_Types:=[op(Obj_Types),kieu $ n];
   fi;
od; </Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># GRAPH_THEORY[xuly_Object]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L137">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[xuly_Param] := proc(SParam)</Font><Font bold="false">
local i;
global Params;
for i in SParam do
   Params := Params union {parse(i)};
od; </Font><Font foreground="[102,51,255]">
end: </Font><Font style="Text" executable="true"># GRAPH_THEORY[xuly_Param]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L138">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[xuly_Hypos] := proc(SHypos)</Font><Font bold="false">
local i,
     update, read_fact, read_func;
global Facts, Functions, Funcs, Func_Types, Hypos, Fact_Kinds, OAttrs, OAttr_Types, Objects, Obj_Types;

update:=proc(ex_vars)

  local vars,i,j;
  vars :=  ex_vars minus (convert(Objects, set) 
                union convert(OAttrs, set) union convert(Funcs, set));
     
  for i in vars do           
    if Is_Function(i) then
           if type_Onet(i) = &quot;type?&quot; then next;fi;
           Funcs:= [op(Funcs), i];
           Func_Types:= [op(Func_Types), type_Onet(i)]; 
           for j in [op(i)] do 
               update(Set_Vars(j));
           od;    
    elif ValidStructName_Onet(i) and Unify_In1({op(i)},Objects) then
                if type_Onet(i) = &quot;type?&quot; then next;fi;
                Obj_Types:=[op(Obj_Types),type_Onet(i)];
                Objects:=[op(Objects),i]; 
    elif type(i,function) and op(0,i)=`.` and 
         not Unify_In1(op(1,i),Objects)and
         ValidStructName_Onet(op(1,i)) and 
         Unify_In1({op(op(1,i))},Objects) then
                if type_Onet(i) = &quot;type?&quot; then next;fi;
                Obj_Types:=[op(Obj_Types),type_Onet(op(1,i))];
                Objects:=[op(Objects),op(1,i)];          
                OAttrs := [op(OAttrs), i] ;
                OAttr_Types := [op(OAttr_Types), type_Onet(i)];
    else
                if type_Onet(i) = &quot;type?&quot; then next;fi;
 		OAttrs := [op(OAttrs), i] ;
                OAttr_Types := [op(OAttr_Types), type_Onet(i)];
    fi; 
  od;           
end:

read_fact:=proc(i)
local k,s,ex_vars,ex;
  ex_vars := {};
  s := [parse(i)];
  for  ex in s do       
     k :=  Kind_Fact(ex);
     if  k&gt;=1 and k&lt;=11 and not Unify_In1(ex,Facts)then   
          Facts := {op(Facts), ex};          
          Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex];
          ex_vars := ex_vars union Set_Vars(ex);
        fi;
     od;  
  update(ex_vars);
end: </Font><Font style="Text" executable="true"># read_fact</Font><Font bold="false">

read_func:=proc(i)
local k,s,ex_vars,ex;
  ex_vars := {};   
  s := [parse(i)];  
  for  ex in s do    
     k :=  Kind_Fact(ex);
     if  k&gt;=1 and k&lt;=11 and not Unify_In1(ex,Functions) then   
         Functions := {op(Functions), ex};          
         Fact_Kinds[k] :=[op(Fact_Kinds[k]),ex]; 
         ex_vars := ex_vars union Set_Vars(ex);         
     fi;        
  od;  
  update(ex_vars);
end: </Font><Font style="Text" executable="true">#  read_func
</Font>
 
   <Font bold="false">for i in SHypos do
      if not Is_Function(i) then
         read_fact(i); 
      else read_func(i); fi;
   od; </Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># GRAPH_THEORY[xuly_Hypos]</Font></Text-field>
</Input>
</Group>
<Group labelreference="L139">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[xuly_Goal] := proc(SGoal)</Font><Font bold="false">
global Goals, Funcs, Func_Types, Objects, Obj_Types, OAttrs, OAttr_Types;
local s,ex,ex_vars,k, i, update;</Font>

  <Font bold="false">update:=proc(ex_vars)
  local vars,i,j;
  vars :=  ex_vars minus (convert(Objects, set) 
                union convert(OAttrs, set) union convert(Funcs, set));
     
  for i in vars do           
    if Is_Function(i) then
           if type_Onet(i) = &quot;type?&quot; then next;fi;
           Funcs:= [op(Funcs), i];
           Func_Types:= [op(Func_Types), type_Onet(i)]; 
           for j in [op(i)] do 
               update(Set_Vars(j));
           od;    
    elif ValidStructName_Onet(i) and Unify_In1({op(i)},Objects) then
                if type_Onet(i) = &quot;type?&quot; then next;fi;
                Obj_Types:=[op(Obj_Types),type_Onet(i)];
                Objects:=[op(Objects),i]; 
    elif type(i,function) and op(0,i)=`.` and 
         not Unify_In1(op(1,i),Objects)and
         ValidStructName_Onet(op(1,i)) and 
         Unify_In1({op(op(1,i))},Objects) then
                if type_Onet(i) = &quot;type?&quot; then next;fi;
                Obj_Types:=[op(Obj_Types),type_Onet(op(1,i))];
                Objects:=[op(Objects),op(1,i)];          
                OAttrs := [op(OAttrs), i] ;
                OAttr_Types := [op(OAttr_Types), type_Onet(i)];
    else
                if type_Onet(i) = &quot;type?&quot; then next;fi;
 		OAttrs := [op(OAttrs), i] ;
                OAttr_Types := [op(OAttr_Types), type_Onet(i)];
    fi; 
  od;           
end: </Font><Font style="Text" executable="true"># update</Font>
   
   <Font bold="false">s :=[];
   for i in SGoal do s := [op(s),parse(i)]; od;
   ex_vars := {};
   for  ex in s  do         
         k :=  Kind_Fact(ex);
         if  (k&gt;=1 and k&lt;=11) or member(ex,Params) and not Unify_In1(ex,Goals) then  
             Goals := [op(Goals), ex];
             ex_vars := ex_vars union Set_Vars(ex);
         fi;
       od;
       update(ex_vars); </Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># GRAPH_THEORY[xuly_Goal]</Font></Text-field>
</Input>
</Group>
</Section>
<Group labelreference="L140">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group labelreference="L141">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font size="20">#---------------------</Font><Font style="Text">
<Font size="22"># <Font encoding="UTF-8">Gi\341\272\243i to\303\241n</Font></Font></Font></Text-field>
</Input>
</Group>
<Group labelreference="L142">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font><Font foreground="[153,102,255]">Test_Goal]:=proc(Goal, Facts)</Font> <Font bold="false">
  return Unify_In1(Goal,Facts);</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Test_Goal</Font></Text-field>
</Input>
</Group>
<Group labelreference="L143">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-------------------</Text-field>
</Input>
</Group>
<Group labelreference="L144">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Output_Result]:=proc(Goal)</Font><Font bold="false">
local facts, t,value,Solution,i,j;
global Fact_Kinds, Sol;  </Font><Font style="Text">

Solution:=proc()
  local goalvars,Solnew,Step,i;

  goalvars:={Goal};
  Solnew:=[];
  
  for i from nops(Sol) to 1 by -1 do
      Step:=Sol[i];      
      if  Intersect_Unify(Step[4], goalvars) &lt;&gt; {}  then         
         Step[4] := Intersect_Unify(Step[4], goalvars);         
         Solnew := [Step, op(Solnew)];
         goalvars := Union_Unify(Minus_Unify(goalvars, Step[4]), Step[3]);
      fi; 
  od;
  return(Solnew);
end:</Font><Font bold="false">
Solution:=proc()
  local goalvars,Solnew,Step,i;
  goalvars:={Goal};
  Solnew:=[];
  for i from nops(Sol) to 1 by -1 do
      Step:=Sol[i];      
      if  Intersect_Unify(Step[4],goalvars) &lt;&gt; {} or `intersect`(Step[4],goalvars)&lt;&gt;{} then         
         Step[4] := Intersect_Unify(Step[4],goalvars) union `intersect`(Step[4],goalvars);
         if Step[1] &lt;&gt; &quot;Deduce_From3s&quot; and Step[1] &lt;&gt; &quot;Deduce_From8s&quot; then          
         	Solnew := [Step, op(Solnew)];fi;
         goalvars := Union_Unify(Minus_Unify(goalvars,Step[4]),Step[3]);
      fi; 
  od;
  return(Solnew);
end: </Font><Font style="Text" executable="true"># Solution</Font><Font bold="false">

   if not Test_Goal(Goal, FactSet) then 
<Font encoding="UTF-8">      printf(&quot;\134n  Rat tiec %a khong giai duoc \134n\134n&quot;, Goal); 
</Font>   else 
      value := Get_Values(Goal);
      if type(value,`set`) then
<Font encoding="UTF-8">         printf(&quot;\134n    </Font></Font>***<Font encoding="UTF-8" size="14">K\341\272\276T QU\341\272\242 C\341\272\246N T\303\214M L\303\200:</Font><Font bold="false" encoding="UTF-8"> \134n&quot;);
</Font><Font bold="false">         for i in value do
<Font encoding="UTF-8">              printf(&quot; %a = %a\134n&quot;,Goal,i);
</Font>         od;
      else 
<Font encoding="UTF-8">         printf(&quot;\134n    </Font></Font>***<Font encoding="UTF-8" size="14">K\341\272\276T QU\341\272\242 C\341\272\246N T\303\214M L\303\200:</Font><Font bold="false" encoding="UTF-8"> %a = %a\134n\134n&quot;,Goal,value);
</Font><Font bold="false">      fi;    
      
<Font encoding="UTF-8">      printf(&quot;\134n</Font></Font>*****<Font bold="false"> </Font><Font encoding="UTF-8" size="14">L\341\273\234I GI\341\272\242I NH\306\257 SAU:</Font><Font bold="false"> </Font>*****<Font bold="false" encoding="UTF-8">\134n&quot;); 
</Font><Font bold="false">      for t in Sol do
        printf(&quot; </Font>**<Font bold="false" encoding="UTF-8"> %a\134n&quot;,t);
</Font><Font bold="false">      od;
     </Font><Font encoding="UTF-8"> printf(&quot;\134n\134n***** <Font size="14">L\341\273\234I GI\341\272\242I CHI TI\341\272\276T C\341\273\246A B\303\200I TO\303\201N NH\306\257 SAU:</Font></Font> *****<Font encoding="UTF-8"> \134n&quot;);</Font><Font bold="false">
      for j in </Font>Solution()do
<Font encoding="UTF-8">        printf(&quot; ** %a \134n&quot;,j);</Font><Font bold="false">
      od;
   fi;</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Output_Result</Font></Text-field>
</Input>
</Group>
<Group labelreference="L145">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#-----------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L146">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Determine]:= proc(Goal)</Font><Font bold="false">
local  Init,
       dem, lan, Rules_Temp, time_Deter;
global Found, flag,Objects,Obj_Types;

  <Font foreground="[153,51,255]"> Init:= proc()</Font><Font foreground="[255,51,51]">
      Found:=false;
      flag:=true;</Font>
      dem:=0;
      lan:=0;
      time_Deter:=time();
  <Font foreground="[153,51,255]">end:  </Font></Font><Font style="Text" executable="true">#   Init</Font><Font bold="false" foreground="[51,51,0]">

 </Font><Font bold="false" foreground="[153,51,255]"> </Font><Font style="Text"># Determine'body  </Font><Font bold="false">   
   Init();      
   while  not Found and flag do
      if  (time()-time_Deter) &gt; 200  then   </Font><Font style="Text" executable="true" encoding="UTF-8">#  Cho ph\303\251p l\341\272\267p t\341\273\221i \304\221a trong 200 gi\303\242y</Font><Font bold="false">
         lprint(&quot; Out of time.&quot;);
         break;
      fi; 

      flag:=false;
      lan:=lan+1;
<Font encoding="UTF-8">      printf(&quot; **L\341\272\247n = %a&quot;,lan, color = red);
</Font>
 #-BUOC1----------------------------------
      </Font><Font style="Text" encoding="UTF-8"># \303\201p d\341\273\245ng Deduce_From3s \304\221\341\272\277 ph\303\241t sinh c\303\241c s\341\273\261 ki\341\273\207n 2 t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n 3 </Font><Font bold="false">  
      if {op(Fact_Kinds[3])} &lt;&gt; DF3 then 
	 print(&quot;vao deduce 3s&quot;);
         Deduce_From3s();
         if flag then  Found:=Test_Goal(Goal,FactSet);next;fi;
      fi;

 #-BUOC2----------------------------------     
      </Font><Font style="Text" encoding="UTF-8"># \303\201p d\341\273\245ng Deduce_From43s \304\221\341\273\203 ph\303\241t sinh c\303\241c s\341\273\261 ki\341\273\207n 3 t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n 4 v\303\240 s\341\273\261 ki\341\273\207n 3 b\341\272\261ng c\303\241ch th\341\272\277 s\341\273\261 ki\341\273\207n 3 v\303\240o s\341\273\261 ki\341\273\207n 4</Font><Font bold="false">
      if {op(Fact_Kinds[4])} &lt;&gt;  DF43	 then
          print(&quot;vao deduce 43s&quot;);
          Deduce_From43s();
          if flag then  Found:=Test_Goal(Goal,FactSet);next;fi;
      fi;

 #-BUOC3----------------------------------     
      </Font><Font style="Text" encoding="UTF-8"># \303\201p d\341\273\245ng Deduce_From53s \304\221\341\273\203 sinh ra c\303\241c s\341\273\261 ki\341\273\207n 3, 4, 5 t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n 5 v\303\240 c\303\241c s\341\273\261 ki\341\273\207n 3 b\341\272\261ng c\303\241ch th\341\272\277 s\341\273\261 ki\341\273\207n 3 v\303\240o s\341\273\261 ki\341\273\207n 5</Font><Font bold="false">
      if {op(Fact_Kinds[5])} &lt;&gt;  DF53	 then
          print(&quot;vao deduce 53s&quot;);
          Deduce_From53s();
          if flag then  Found:=Test_Goal(Goal,FactSet);next;fi;
      fi;

 #-BUOC4----------------------------------     
     </Font><Font style="Text" encoding="UTF-8"> # \303\201p d\341\273\245ng Deduce_From45s \304\221\341\273\203 sinh c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 3 t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 4, 5 b\341\272\261ng c\303\241ch gi\341\272\243i h\341\273\207 ph\306\260\306\241ng tr\303\254nh
</Font><Font style="Text">    </Font><Font executable="false">  <Font bold="false">if {op(Fact_Kinds[4]),op(Fact_Kinds[5])} &lt;&gt;  DF45	 then
          print(&quot;vao deduce 45s&quot;);
          Deduce_From45s();
          if flag then  Found:=Test_Goal(Goal,FactSet);next;fi;
      fi;</Font></Font><Font style="Text">    </Font><Font bold="false">  

 #-BUOC5---------------------------------
      </Font><Font style="Text" encoding="UTF-8"># \303\201p d\341\273\245ng Deduce_From8s \304\221\341\273\203 sinh ra c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 7 t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 8  </Font><Font bold="false">
      if {op(Fact_Kinds[8])} &lt;&gt; DF8  then 
	 print(&quot;vao deduce 8s&quot;);
	 Deduce_From8s();
         if flag then Found:=Test_Goal(Goal,FactSet); next;fi;
      fi; 

 #-BUOC6----------------------------------
      </Font><Font style="Text" encoding="UTF-8"># \303\201p d\341\273\245ng Deduce_From983s \304\221\341\273\203 sinh ra c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 3 (ho\341\272\267c lo\341\272\241i 8) t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 3, 8, 9 ban \304\221\341\272\247u b\341\272\261ng c\303\241ch th\341\272\277 sk3, sk8 v\303\240o sk9</Font><Font bold="false">
      if {op(Fact_Kinds[9])} &lt;&gt; DF9  then
         print(&quot;vao deduce 983s&quot;);
	 Deduce_From983s();
         if flag then Found:=Test_Goal(Goal,FactSet); next;fi;
      fi;

 #-BUOC7------------------------------ 
      </Font><Font style="Text" encoding="UTF-8"># \303\201p d\341\273\245ng Deduce_Objects \304\221\341\273\203 gi\341\272\243i b\303\252n trong c\341\273\247a \304\221\341\273\221i t\306\260\341\273\243ng --&gt; sinh ra c\303\241c s\341\273\261 ki\341\273\207n m\341\273\233i</Font><Font bold="false">      
        print(&quot;vao deduce Objs&quot;);
	Deduce_Objects(Goal);
       	if flag then Found:=Test_Goal(Goal,FactSet); next;fi; 

 #-BUOC8----------------------------------
      </Font><Font style="Text" encoding="UTF-8"># \303\201p d\341\273\245ng Deduce_From9s \304\221\341\273\203 sinh ra c\303\241c s\341\273\261 ki\341\273\207n t\341\273\253 c\303\241c s\341\273\261 ki\341\273\207n lo\341\272\241i 9</Font><Font bold="false">
      if {op(Fact_Kinds[9])} &lt;&gt; DF9  then 
         print(&quot;vao deduce 9s&quot;);
         Deduce_From9s();    
         if flag then  Found:=Test_Goal(Goal,FactSet);next;fi;
      fi;
      
 #-BUOC9----------------------------------   </Font><Font style="Text">  </Font><Font bold="false">
      </Font><Font style="Text" encoding="UTF-8"> # \303\201p d\341\273\245ng lu\341\272\255t \304\221\341\273\203 sinh ra s\341\273\261 ki\341\273\207n m\341\273\233i</Font><Font bold="false"> 
      print(&quot;vao luat&quot;);
      Deduce_Rules();
      if flag then Found:=Test_Goal(Goal,FactSet); next;fi;

 
 #-BUOC11---------------------------------- 
      </Font><Font style="Text" encoding="UTF-8">#  \303\201p d\341\273\245ng Deduce_Eqs \304\221\341\273\203 t\341\272\241o ra s\341\273\261 ki\341\273\207n m\341\273\233i b\341\272\261ng c\303\241ch gi\341\272\243i c\303\241c ph\306\260\306\241ng tr\303\254nh</Font><Font bold="false">
      print(&quot;vao Deduce_EqsGoal&quot;);
     </Font><Font style="Text" foreground="[0,0,255]">  </Font><Font bold="false">Deduce_EqsGoal(Goal);    
      if flag then Found:=Test_Goal(Goal,FactSet); next;fi;

 #-BUOC10---------------------------------- 
      </Font><Font style="Text" encoding="UTF-8"># \303\201p d\341\273\245ng Deduce_Funcs \304\221\341\273\203 ph\303\241t sinh s\341\273\261 ki\341\273\207n m\341\273\233i t\341\273\253 h\303\240m c\303\263 th\341\273\203 \303\241p d\341\273\245ng \304\221\306\260\341\273\243c</Font><Font bold="false">  </Font><Font style="Text">  </Font><Font bold="false">     
   </Font><Font bold="true" style="Text" executable="true">print(&quot;vao ham&quot;);
     </Font><Font bold="true" style="Text">  <Font executable="true">Deduce_Funcs(Goal); 
      print(flag);    
      if flag then Found:=Test_Goal(Goal,FactSet); next;fi;  
      break;</Font></Font><Font bold="false">
 #-BUOC12----------------------------------     
      </Font><Font style="Text" encoding="UTF-8">#  Th\303\252m v\303\240o \304\221\341\273\221i t\306\260\341\273\243ng m\341\273\233i</Font><Font bold="false">
      if ObjsNew &lt;&gt;[] then
        # print(&quot;----&quot;,ObjsNew); print(&quot;-------&quot;,OTypesNew); 
      if dem &lt; 2  then
         print(&quot;--------------THEM DOI TUONG MOI VAO---------&quot;);
         dem:=dem+1; 
         Objects:=[op(Objects),op(ObjsNew)];
         Obj_Types:=[op(Obj_Types),op(OTypesNew)];
         Classify_Facts(FactsNew);
         flag:=true
      fi;
      fi;
  od; </Font><Font style="Text" executable="true"># end while</Font><Font foreground="[153,51,255]">
end proc:  </Font><Font style="Text" executable="true">#  Determine</Font></Text-field>
</Input>
</Group>
<Group labelreference="L147">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#--------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L148">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font><Font foreground="[153,0,255]">Determine_Goal]:=proc(Goal) </Font><Font bold="false">
local Init,
      Values, func, funcstruct, facts, Set, ds, foundds;
global TestF,Sol,ObjsNew,</Font> <Font bold="false">OTypesNew, FactsNew;

  <Font foreground="[153,51,255]">Init:= proc()</Font>
      ObjsNew:=[];</Font>
      <Font bold="false">OTypesNew:=[];</Font>
      <Font bold="false">FactsNew:=[]; 
  <Font foreground="[153,51,255]">end:  </Font></Font><Font style="Text" executable="true">#   Init</Font><Font bold="false"> </Font><Font style="Text">

# Determine_Goal's body</Font><Font bold="false">
Init();
if Is_Function(Goal) then</Font><Font style="Text">
<Font encoding="UTF-8">       #  Th\341\273\261c hi\341\273\207n t\303\254m \304\221\341\273\221i s\341\273\221 c\341\273\247a Goal. N\341\272\277u foundds = true: c\303\241c \304\221\341\273\221i s\341\273\221 \304\221\341\273\201u x\303\241c \304\221\341\273\213nh</Font></Font><Font bold="false">
   for ds in [op(Goal)] do 
      print(&quot;------------------&quot;,ds);
      if not Test_Goal(ds, FactSet) then
         Determine_Goal(ds);	       			
         if not Test_Goal(ds, FactSet) then 
            foundds:= false; break; 
         else foundds:= true;fi;
      else foundds:=true;fi; 
   od;
   </Font><Font style="Text" encoding="UTF-8"># N\341\272\277u c\303\241c \304\221\341\273\221i s\341\273\221 \304\221\341\273\201u \304\221\303\243 x\303\241c \304\221\341\273\213nh th\303\254 ta th\341\273\261c hi\341\273\207n t\303\255nh to\303\241n Goal</Font><Font bold="false">
   if foundds then
      Values:= Get_Values([op(Goal)]) ;        
      func:=type_Onet(Goal);
      funcstruct:=Find_FuncStruct(func); 
      facts:= Compute_Func(funcstruct,[op(Goal)],Values);
      TestF:=TestF union {[func,[op(Goal)]]};
      Set:=Classify_Facts([op(facts)]);
      <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Determine_Goal&quot;,func,{seq(op(Goal)[i]=Get_Values(op(Goal)[i]),i = 1..nops(Goal))},Set]];</Font>
   fi;	
else 
   Determine(Goal);
fi;</Font><Font foreground="[153,51,255]">
end: </Font><Font style="Text" executable="true"># Determine_Goal</Font></Text-field>
</Input>
</Group>
<Group labelreference="L149">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#--------------------------</Text-field>
</Input>
</Group>
<Group labelreference="L150">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[Determine_Goals]:=proc()</Font><Font bold="false">
local Init,Goal,t,
      time1;
global FactSet, TestF, TestR,TestOR,TestOCR,Sol,Goals,DF3, DF43,DF53,DF45, DF9, DF8,TestProp,chiso, flagObj;
time1:=time();
   <Font foreground="[153,51,255]">Init:= proc()</Font><Font foreground="[255,51,51]">
      FactSet:=Hypos;
      Sol:=[]; 
      </Font>DF3:= {};        </Font><Font style="Text" executable="true" encoding="UTF-8"># L\306\260u c\303\241c s\306\260u ki\341\273\207n lo\341\272\241i 3 \304\221\303\243 x\341\273\255 l\303\275</Font><Font bold="false">
      DF43:= {};       </Font><Font style="Text" executable="true"># <Font encoding="UTF-8">L\306\260u c\303\241c s\306\260u ki\341\273\207n lo\341\272\241i 4 \304\221\303\243 x\341\273\255 l\303\275</Font></Font><Font bold="false">
      DF53:= {};       </Font><Font style="Text" executable="true"># <Font encoding="UTF-8">L\306\260u c\303\241c s\306\260u ki\341\273\207n lo\341\272\241i 5 \304\221\303\243 x\341\273\255 l\303\275</Font></Font><Font bold="false">
      DF45:= {};       </Font><Font style="Text" executable="true"># <Font encoding="UTF-8">L\306\260u c\303\241c s\306\260u ki\341\273\207n lo\341\272\241i 45 \304\221\303\243 x\341\273\255 l\303\275</Font></Font><Font bold="false">
      DF8:={};         </Font><Font style="Text" executable="true"># <Font encoding="UTF-8">L\306\260u c\303\241c s\306\260u ki\341\273\207n lo\341\272\241i 8 \304\221\303\243 x\341\273\255 l\303\275</Font></Font><Font bold="false">  <Font foreground="[255,51,51]">
      </Font>DF9:= {};        </Font><Font style="Text" executable="true"># <Font encoding="UTF-8">L\306\260u c\303\241c s\306\260u ki\341\273\207n lo\341\272\241i 9 \304\221\303\243 x\341\273\255 l\303\275</Font></Font><Font bold="false" foreground="[255,51,51]">
     </Font><Font bold="false"> TestF:={};       </Font><Font style="Text" executable="true" encoding="UTF-8"># L\306\260u c\303\241c h\303\240m v\303\240 c\303\241c \304\221\341\273\221i s\341\273\221 \304\221\303\243 x\341\273\255 l\303\275</Font><Font bold="false"> 
      TestR:={};       </Font><Font style="Text" executable="true" encoding="UTF-8"># L\306\260u c\303\241c lu\341\272\255t v\303\240 c\303\241c \304\221\341\273\221i s\341\273\221 \304\221\303\243 x\341\273\255 l\303\275</Font><Font bold="false"> 
      TestOR:={};      </Font><Font style="Text" executable="true" encoding="UTF-8"># L\306\260u c\303\241c lu\341\272\255t b\303\252n trong \304\221\341\273\221i t\306\260\341\273\243ng \304\221\303\243 x\341\273\255 l\303\275</Font><Font bold="false"> 
      TestOCR:={};     </Font><Font style="Text" executable="true" encoding="UTF-8"># L\306\260u c\303\241c quan h\341\273\207 t\303\255nh to\303\241n b\303\252n trong \304\221\341\273\221i t\306\260\341\273\243ng \304\221\303\243 x\341\273\255 l\303\275</Font><Font bold="false">   
      TestProp:={};    </Font><Font style="Text" executable="true" encoding="UTF-8"># L\306\260u t\303\254nh tr\341\272\241ng c\303\241c t\303\255nh ch\341\272\245t b\303\252n trong \304\221\341\273\221i t\306\260\341\273\243ng \304\221\303\243 x\341\273\255 l\303\275</Font><Font bold="false">  
      chiso:= 1;       </Font><Font style="Text" executable="true" encoding="UTF-8"># L\306\260u ch\341\273\211 s\341\273\221 d\303\271ng trong qu\303\241 tr\303\254nh sinh ra \304\221\341\273\221i t\306\260\341\273\243ng m\341\273\233i</Font><Font bold="false"> 
      flagObj:=false;   
  <Font foreground="[153,51,255]">end:  </Font></Font><Font style="Text" executable="true">#   Init</Font><Font bold="false"> </Font><Font style="Text">

# Determine_Goals's body</Font><Font bold="false">
   Init();
   <Font foreground="[255,51,51]">for t in Goals do
	if type(t, function) and op(0,t)=`.` and NameType(op(1,t))=&quot;DOAN&quot; and op(2,t)= a then 
	flagObj:=true;break;fi;
   od;</Font>
   for Goal in Goals do
      
      if Test_Goal(Goal,FactSet) then 
<Font encoding="UTF-8">         printf(&quot; ***Bai toan khong can giai\134n&quot;);
</Font>         <Font foreground="[255,0,51]">Output_Result(Goal);</Font>
      else	
        Determine_Goal(Goal);
     </Font> 	<Font bold="false" foreground="[255,0,51]">Output_Result(Goal);</Font><Font bold="false">
        
      fi;
   od;</Font><Font foreground="[153,51,255]">
lprint(`Total Time`,time()-time1);
end proc:  </Font><Font style="Text" executable="true">#  Determine_Goals</Font></Text-field>
</Input>
</Group>
<Group labelreference="L151">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[153,51,255]">GRAPH_THEORY[</Font>Determine_Param] := proc(Par)<Font style="Text">  <Font encoding="UTF-8"># Th\341\273\247 t\341\273\245c x\303\241c \304\221\341\273\213nh m\341\273\231t gi\303\241 tr\341\273\213 m\341\273\231t tham s\341\273\221</Font>
</Font><Font bold="false">local facts,obj,Eqs, 
      find_obj, call_func, find_fact9,<Font foreground="[0,153,153]">GetVars_Poly,</Font>set_eqs,test_goal,Init;
global Fact_Kinds, Sol;
      find_obj := proc(par)
      local fact, objs;
         for fact in Fact_Kinds[3] do 
            if member(par,Set_Vars(rhs(fact))) then 
               if type_Onet(rhs)=&quot;PTDT_TQ&quot; then return op(lhs(fact))[1];fi;
               return lhs(fact);
            fi;
         od;         
      end: </Font><Font style="Text" executable="true"># find_obj</Font><Font bold="false"> 
  
      call_func := proc(func)
      local fname;
         fname := Find_FuncStruct(type_Onet(func)); fname := parse(fname[4]);
         return fname(op(Get_Values([op(func)])));   
      end: </Font><Font style="Text" executable="true"># call_func</Font><Font bold="false">     
 
      <Font foreground="[0,153,153]">GetVars_Poly:=proc(expr)</Font>
      local F,i;
         if  type(expr, constant) or type(expr, string) then return({});
         elif type(expr,`name`)or type(expr,`indexed`) or 
           (type(expr, function) and evalb(op(0,expr) = &quot;.&quot; ))then return {expr};
         elif type(expr,`set`) or type(expr,list)then
            F:={}; 
            for i in expr do F:= F union GetVars_Poly(i);od; 
            return F;   
         else F:= GetVars_Poly({op(expr)}); return F;fi;
       <Font foreground="[0,102,102]">end :  </Font></Font><Font style="Text" executable="true">#  GetVars_Poly</Font><Font bold="false" foreground="[0,102,102]"> </Font><Font bold="false">

      set_eqs :=proc(vt,vp)  
      local j,eqs;
         eqs:={}; 
         if nops(vt) &lt;&gt; 1 then
            for j to nops(vt) do 
               if GetVars_Poly(vt[j]=vp[j]) &lt;&gt; {} then
                  eqs := eqs union {vt[j]=vp[j]};
               fi;  
            od;
            return eqs; 
         else return {vt=vp};  
         fi;
      end: </Font><Font style="Text" executable="true">#set_eqs</Font><Font bold="false"> 
     
      find_fact9 := proc(otemp)
      local fact9, vt,vp, eqs, ans, j, kq;
         for fact9 in Fact_Kinds[9] do
           if member(otemp,{lhs(fact9),op(rhs(fact9))}) then 
            vt := Get_Values(lhs(fact9));vp:= call_func(rhs(fact9));
            eqs := set_eqs(vt,vp);ans := GetVars_Poly(eqs);
            <Font opaque="true" background="[204,204,204]">Sol:=[op(Sol),[&quot;Ap dung sk 9&quot;,[fact9],{lhs(fact9),op(rhs(fact9))},eqs]]; </Font>
               if nops(eqs)=nops(ans) then
                   kq := solve(eqs,ans);                   
                  <Font opaque="true" background="[204,204,204]"> Sol := [op(Sol),[&quot;Giai pt&quot;,[],eqs,kq]];</Font>
                   return kq;
               fi;
               Eqs := Eqs union eqs; 
            fi;
         od; 
      end: </Font><Font style="Text" executable="true"># find_fact9</Font><Font bold="false">
      
      test_goal := proc(par,otemp, temp) 
      local j,f, o;
         for j to nops(temp) do
            if par = lhs(temp[j]) then
<Font encoding="UTF-8">               printf(&quot; B\303\240i to\303\241n gi\341\272\243i \304\221\306\260\341\273\243c.&quot;);
               printf(&quot;\134n </Font></Font>***<Font encoding="UTF-8" size="14">K\341\272\277t qu\341\272\243 l\303\240:</Font><Font bold="false"> %a&quot;, temp[j]);
<Font encoding="UTF-8">               printf(&quot;\134n </Font></Font><Font encoding="UTF-8" size="14">***** L\341\273\235i gi\341\272\243i l\303\240:</Font><Font bold="false"> </Font>*****<Font bold="false" encoding="UTF-8">\134n%a&quot;,Sol)  ; 
</Font><Font bold="false">               for f to nops(Fact_Kinds[3]) do
                  if otemp = lhs(Fact_Kinds[3][f]) then
                     Fact_Kinds[3][f]:= subs(temp[j],Fact_Kinds[3][f]);
                  fi;
               od;
               return true;
            fi;  
         od;
         return false;
      end: </Font><Font style="Text" executable="true"># test_goal</Font><Font style="Text">

# Determine_Param's body</Font><Font bold="false">
   #trace(find_fact9);trace(find_obj);trace(call_func);
   obj := find_obj(Par); Eqs := {};   Sol:= [];
   facts := find_fact9(obj);
   if test_goal(Par,obj,facts) then return;fi;</Font>
   return Eqs;
end: <Font style="Text" executable="true"># Determine_Param</Font></Text-field>
</Input>
</Group>
<Group labelreference="L152">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,102,102]">url:= currentdir();</Font><Font bold="false">
save(GRAPH_THEORY,cat(url,&quot;</Font>/GRAPH_THEORY<Font bold="false">.m&quot;));
</Font></Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUkjbWlHRiQ2JVEkdXJsRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEjOj1GJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTC1JI21zR0YkNiNRP0Q6XERpc2NyZXRlTWF0aGVtYXRpY3NcUGFja2FnZUYnLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lK2JhY2tncm91bmRHUS5bMjU1LDI1NSwyNTVdRicvJSlyZWFkb25seUdGPUY5">UT9EOlxEaXNjcmV0ZU1hdGhlbWF0aWNzXFBhY2thZ2U2Ig==</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L153">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font bold="false">restart;</Font></Text-field>
</Input>
</Group>
<Group labelreference="L154">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font bold="false" foreground="[255,102,102]">url:= currentdir();</Font></Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUkjbWlHRiQ2JVEkdXJsRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEjOj1GJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTC1JI21zR0YkNiNRP0Q6XERpc2NyZXRlTWF0aGVtYXRpY3NcUGFja2FnZUYnLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lK2JhY2tncm91bmRHUS5bMjU1LDI1NSwyNTVdRicvJSlyZWFkb25seUdGPUY5">UT9EOlxEaXNjcmV0ZU1hdGhlbWF0aWNzXFBhY2thZ2U2Ig==</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L155">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">libname := libname,url;</Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUkjbWlHRiQ2JVEobGlibmFtZUYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIzo9RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwtRiM2Ky1JI21zR0YkNiNRPkM6XFByb2dyYW1+RmlsZXNcTWFwbGV+MTdcbGliRictRjY2LVEiLEYnRjlGOy9GP0YxRkBGQkZERkZGSC9GS1EmMC4wZW1GJy9GTlEsMC4zMzMzMzMzZW1GJy1GUjYjUSIuRidGVS1GUjYjUT9EOlxEaXNjcmV0ZU1hdGhlbWF0aWNzXFBhY2thZ2VGJy8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJStiYWNrZ3JvdW5kR1EuWzI1NSwyNTUsMjU1XUYnLyUpcmVhZG9ubHlHRj1GOUZdb0Zgb0Zjb0Y5">NiVRPkM6XFByb2dyYW1+RmlsZXNcTWFwbGV+MTdcbGliNiJRIi5GJFE/RDpcRGlzY3JldGVNYXRoZW1hdGljc1xQYWNrYWdlRiQ=</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L156">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">with(GRAPH_THEORY);</Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">N2ZwSSpBcHBseVJ1bGVHNiJJKUF0dHJOYW1lR0YkSSpCZWxvbmdfSW5HRiRJL0NsYXNzaWZ5X0ZhY3RzR0YkSS9DbGFzc2lmeV9SdWxlc0dGJEktQ29tcHV0ZV9GdW5jR0YkSS9EZWR1Y2VfRXFzR29hbEdGJEktRGVkdWNlX0Zyb20zR0YkSS5EZWR1Y2VfRnJvbTNzR0YkSS9EZWR1Y2VfRnJvbTQzc0dGJEkvRGVkdWNlX0Zyb201M3NHRiRJLURlZHVjZV9Gcm9tOEdGJEkuRGVkdWNlX0Zyb204c0dGJEktRGVkdWNlX0Zyb205R0YkSTBEZWR1Y2VfRnJvbTk4M3NHRiRJLkRlZHVjZV9Gcm9tOXNHRiRJLURlZHVjZV9GdW5jc0dGJEkuRGVkdWNlX09iamVjdEdGJEktRGVkdWNlX1J1bGVzR0YkSSpEZXRlcm1pbmVHRiRJL0RldGVybWluZV9Hb2FsR0YkSTBEZXRlcm1pbmVfR29hbHNHRiRJMERldGVybWluZV9QYXJhbUdGJEkwRmluZF9GYWN0X1R5cGVzR0YkSTBGaW5kX0Z1bmNTdHJ1Y3RHRiRJMUZpbmRfT2RpbmFyeUZ1bmNHRiRJLkZpbmRfVmFyVW5pZnlHRiRJK0dldF9WYWx1ZXNHRiRJLEhhc19FbGVtZW50R0YkSS1IYXNfRnVuY3Rpb25HRiRJK0hhc19PYmplY3RHRiRJMEludGVyc2VjdF9VbmlmeUdGJEkuSXNFcXVhbF9VbmlmeUdGJEksSXNfRGFjVHJ1bmdHRiRJK0lzX0VsZW1lbnRHRiRJKUlzX0VxdWFsR0YkSSxJc19GdW5jdGlvbkdGJEkqSXNfT2JqZWN0R0YkSTBJc19SZWxhdGlvblR5cGVHRiRJKktpbmRfRmFjdEdGJEksTWludXNfVW5pZnlHRiRJK015Q29tYmluYXRHRiRJKU5hbWVUeXBlR0YkSSpPYmpTdHJ1Y3RHRiRJMk9ialN0cnVjdF9SZXBsYWNlR0YkSS5PZGluYXJ5X0h5cG9zR0YkSTRPZGluYXJ5X0h5cG9zX1J1bGVzR0YkSS5PdXRwdXRfUmVzdWx0R0YkSSxSZWFkQ09iamVjdEdGJEkpUmVhZEV4ZXJHRiRJKVJlbGFQcm9wR0YkSSlSZXBsYWNlUkdGJEkxUmVwbGFjZV9BdHRyTmFtZUdGJEkrUmVwbGFjZV9EU0dGJEkzUmVwbGFjZV9TdHJ1Y3ROYW1lR0YkSS5SZXBsYWNlX1VuaWZ5R0YkSStSZXNldF9PbmV0R0YkSSlTZXRfVmFyc0dGJEkqU29sdmVGYWN0R0YkSStTdHJ1Y3ROYW1lR0YkSShTdWJMaXN0R0YkSSVUZXN0R0YkSSpUZXN0X0dvYWxHRiRJK1VuaWZ5X0ZhY3RHRiRJKVVuaWZ5X0luR0YkSSpVbmlmeV9JbjFHRiRJLFVuaW9uX1VuaWZ5R0YkSTVWYWxpZFN0cnVjdE5hbWVfT25ldEdGJEklYWRkVkdGJEkpZ2V0X0dvYWxHRiRJKmdldF9IeXBvc0dGJEkrZ2V0X09iamVjdEdGJEkqZ2V0X1BhcmFtR0YkSS1nZXRfU29sdXRpb25HRiRJJWluaXRHRiRJKHB0ZHNzZHRHRiRJJ3B0ZHQyZEdGJEkocHRkdGhzZ0dGJEkncHRkdHNzR0YkSSdwdGR0dmdHRiRJKHB0ZHZnZHRHRiRJJXRscHRHRiRJKXRscHRkc3NkR0YkSSl0bHB0ZHZnZEdGJEkkdHZoR0YkSSp0eXBlX09uZXRHRiRJKnh1bHlfR29hbEdGJEkreHVseV9IeXBvc0dGJEkseHVseV9PYmplY3RHRiRJK3h1bHlfUGFyYW1HRiQ=</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L157">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font encoding="UTF-8">print(&quot;S\341\273\221 l\306\260\341\273\243ng ph\341\272\247n t\341\273\255 trong Facts:&quot;, nops(Facts));</Font></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRRZW5TJiM3ODg5O35sJiM0MzI7JiM3OTA3O25nfnBoJiM3ODQ3O25+dCYjNzkxNzt+dHJvbmd+RmFjdHM6NiIiIiI=</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L165" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">for fact in Facts do    print(fact);end do;</Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">SSZGYWN0c0c2Ig==</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L166" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group labelreference="L167" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
</Section>
</Worksheet>